<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ReengKi 관리자 시스템</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="/static/css/admin.css" rel="stylesheet">
    <style>
        /* Responsive layout adjustments only */
        .admin-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .header {
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .main-content {
            display: flex;
            flex: 1;
        }

        .sidebar {
            transition: transform 0.3s ease;
        }

        .content {
            flex: 1;
            overflow-x: auto;
        }

        .mobile-menu-toggle {
            display: none;
        }

        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 998;
        }

        /* Modal z-index fix */
        .modal {
            z-index: 1060 !important;
        }

        .modal-backdrop {
            z-index: 1055 !important;
        }

        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            .mobile-menu-toggle {
                display: block;
            }

            .main-content {
                position: relative;
            }

            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                transform: translateX(-100%);
                z-index: 999;
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .sidebar-overlay.show {
                display: block;
            }

            .content {
                width: 100%;
                padding: 1rem;
            }
        }

        /* Small mobile adjustments */
        @media (max-width: 576px) {
            .content {
                padding: 0.75rem;
            }
        }
        
        /* Upload progress styling */
        #uploadProgressSection {
            background-color: #f8f9fa;
            border-radius: 0.5rem;
        }
        
        #uploadProgressBar {
            background-color: #28a745;
            transition: width 0.3s ease;
        }
        
        #uploadProgressText {
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .progress {
            background-color: #e9ecef;
            box-shadow: inset 0 1px 2px rgba(0,0,0,.1);
        }
        
        /* Folder View Styles */
        .folder-grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 10px;
            padding: 15px;
            min-height: 300px;
        }
        
        .folder-item, .file-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 4px; /* 패딩 감소 */
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            color: inherit;
            background: transparent;
            border: 1px solid transparent;
            min-height: 90px; /* 높이 조정 */
            position: relative; /* 컨텍스트 메뉴 위치 기준점 */
        }
        
        /* 호버 영역을 아이콘과 텍스트 포함하도록 설정 */
        .folder-item .hover-zone,
        .file-item .hover-zone {
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% - 8px); /* 좌우 여백 제외한 전체 너비 */
            height: 70px; /* 아이콘(40px) + 텍스트 영역 포함 */
            border-radius: 10px;
            z-index: 0;
            transition: all 0.15s ease;
        }
        
        .folder-item:hover .hover-zone,
        .file-item:hover .hover-zone {
            background-color: rgba(0, 123, 255, 0.08); /* 살짝 파란빛 배경 */
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .folder-item:hover,
        .file-item:hover {
            text-decoration: none;
            color: inherit;
        }
        
        .folder-item.selected, .file-item.selected {
            background-color: transparent;
            border-color: transparent;
        }
        
        /* 선택된 항목의 hover-zone 스타일 */
        .folder-item.selected .hover-zone,
        .file-item.selected .hover-zone {
            background-color: rgba(33, 150, 243, 0.15); /* 선택 시 파란색 배경 */
            border: 1px solid #2196f3;
        }
        
        .item-icon,
        .folder-item .item-icon,
        .file-item .item-icon {
            font-size: 2rem !important; /* 크기 축소 - !important로 강제 적용 */
            margin-bottom: 8px;
            color: #6c757d;
            pointer-events: none; /* 아이콘 클릭 방지 */
            user-select: none; /* 텍스트 선택 방지 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 40px; /* 고정 높이 */
            width: 40px; /* 고정 너비 */
            margin: 0 auto 8px auto; /* 가운데 정렬 */
            position: relative;
            z-index: 1; /* hover-zone 위에 표시 */
        }
        
        /* 아이콘 내부 FontAwesome 아이콘들 */
        .item-icon i,
        .folder-item .item-icon i,
        .file-item .item-icon i {
            font-size: 2rem !important;
            pointer-events: none !important;
            user-select: none !important;
        }
        
        /* Icon styles moved to /static/css/admin.css */
        
        .item-name {
            font-size: 0.75rem;
            text-align: center;
            word-break: break-word;
            line-height: 1.2;
            max-height: 2.4em;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            position: relative;
            z-index: 1; /* hover-zone 위에 표시 */
        }
        
        .item-details {
            font-size: 0.65rem;
            color: #6c757d;
            margin-top: 3px;
        }
        
        .breadcrumb-item a {
            color: #0d6efd;
            text-decoration: none;
        }
        
        .breadcrumb-item a:hover {
            text-decoration: underline;
        }
        
        /* Context Menu */
        .context-menu {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            min-width: 150px;
        }
        
        /* Info Sidebar */
        .info-sidebar {
            position: fixed;
            top: 0;
            right: -650px;
            width: 650px;
            height: 100vh;
            background: white;
            border-left: 1px solid #dee2e6;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            z-index: 1050;
            transition: right 0.3s ease;
            overflow-y: auto;
        }
        
        .info-sidebar.open {
            right: 0;
        }
        
        .info-sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1040;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        .info-sidebar-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        
        .info-sidebar-header {
            padding: 1.2rem 1.5rem;
            border-bottom: 1px solid #dee2e6;
            background: #f8f9fa;
        }
        
        .info-sidebar-content {
            padding: 1.5rem;
        }
        
        /* Better alignment for subtitle edit form */
        .subtitle-item {
            background-color: #f8f9fa;
        }
        
        .subtitle-item:hover {
            background-color: #e9ecef;
        }
        
        /* Consistent badge and text sizes */
        .table .badge {
            font-size: 12px;
            padding: 0.35em 0.65em;
        }
        
        /* Responsive form labels */
        .form-label.small {
            font-size: 12px;
            font-weight: 600;
            color: #495057;
        }
        
        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }
        
        .context-menu-item:hover {
            background-color: #f8f9fa;
        }
        
        .context-menu-item:last-child {
            border-bottom: none;
        }
        
        /* Playable video styles */
        .playable-video .item-icon {
            position: relative;
        }
        
        .play-overlay {
            position: absolute;
            bottom: -5px;
            right: -5px;
            background: white;
            border-radius: 50%;
            font-size: 20px;
            color: #0d6efd;
            display: none;
            pointer-events: none; /* 플레이 오버레이도 클릭 방지 */
            user-select: none;
        }
        
        .playable-video:hover .play-overlay {
            display: block;
        }
        
        .playable-video {
            cursor: pointer;
        }
        
        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .folder-grid {
                grid-template-columns: repeat(8, 1fr);
            }
        }
        
        @media (max-width: 992px) {
            .folder-grid {
                grid-template-columns: repeat(6, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .folder-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 8px;
                padding: 10px;
            }
        }
        
        @media (max-width: 576px) {
            .folder-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .item-icon,
            .folder-item .item-icon,
            .file-item .item-icon {
                font-size: 1.8rem !important; /* 모바일에서도 축소 */
                height: 35px !important;
                width: 35px !important;
            }
            
            .item-icon i,
            .folder-item .item-icon i,
            .file-item .item-icon i {
                font-size: 1.8rem !important;
            }
            
            .item-name {
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="admin-container">
        <header class="header">
            <div class="header-content">
                <button class="btn-icon mobile-menu-toggle" onclick="toggleSidebar()">
                    <i class="fas fa-bars"></i>
                </button>
                <h1 class="logo">ReengKi</h1>
                <div class="header-actions">
                    <button class="btn-icon">
                        <i class="fas fa-ellipsis-v"></i>
                    </button>
                </div>
            </div>
        </header>

        <div class="sidebar-overlay" onclick="closeSidebar()"></div>

        <div class="main-content">
            <nav class="sidebar" id="sidebar">
                <div class="sidebar-content">
                    <ul class="nav-menu">
                        <li class="nav-item">
                            <a class="nav-link" href="/dashboard/assets">
                                <i class="fas fa-th-large"></i> 에셋 관리
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="/dashboard">
                                <i class="fas fa-home"></i> 대시보드
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>

            <main class="content">
                <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                    <h1 class="h2">에셋 관리</h1>
                    <div class="btn-toolbar mb-2 mb-md-0">
                        <div class="btn-group me-2">
                            <button type="button" class="btn btn-sm btn-outline-primary" id="addAssetBtn">
                                <i class="fas fa-plus"></i> 에셋 추가
                            </button>
                            <button type="button" class="btn btn-sm btn-outline-secondary" onclick="refreshAssets()">
                                <i class="fas fa-sync"></i> 새로고침
                            </button>
                        </div>
                        <div class="btn-group">
                            <button type="button" class="btn btn-sm btn-outline-secondary" data-bs-toggle="modal" data-bs-target="#importModal">
                                <i class="fas fa-upload"></i> JSON 가져오기
                            </button>
                            <button type="button" class="btn btn-sm btn-outline-secondary" onclick="exportAssets()">
                                <i class="fas fa-download"></i> JSON 내보내기
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Search Bar -->
                <div class="card mb-4">
                    <div class="card-body">
                        <div class="row align-items-center">
                            <div class="col-12">
                                <div class="input-group">
                                    <input type="text" class="form-control" id="searchInput" placeholder="파일 및 폴더 검색..." oninput="filterItems()" onkeydown="handleSearchKeydown(event)">
                                    <button class="btn btn-outline-secondary" type="button" onclick="clearSearch()" id="clearSearchBtn" style="display: none;">
                                        <i class="fas fa-times"></i>
                                    </button>
                                    <button class="btn btn-outline-secondary" type="button" onclick="searchFiles()">
                                        <i class="fas fa-search"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Folder View -->
                <div class="card shadow" id="folderView">
                    <div class="card-header py-3">
                        <div class="row align-items-center">
                            <div class="col">
                                <!-- Breadcrumb Navigation -->
                                <nav aria-label="breadcrumb">
                                    <ol class="breadcrumb mb-0" id="breadcrumbNav">
                                        <li class="breadcrumb-item active">Home</li>
                                    </ol>
                                </nav>
                            </div>
                            <div class="col-auto">
                                <span id="itemCount" class="badge bg-secondary">0 items</span>
                            </div>
                        </div>
                    </div>
                    <div class="card-body p-0">
                        <!-- Loading Indicator -->
                        <div id="loadingIndicator" class="text-center p-5" style="display: none;">
                            <div class="spinner-border text-primary mb-3" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <h5 class="text-muted">폴더 구조를 로딩 중...</h5>
                            <p class="text-muted">잠시만 기다려 주세요.</p>
                        </div>
                        
                        <!-- Folder Contents -->
                        <div id="folderContents" class="folder-grid">
                        </div>
                        
                        <!-- Empty State -->
                        <div id="emptyState" class="text-center p-5" style="display: none;">
                            <i class="fas fa-folder-open fa-3x text-muted mb-3"></i>
                            <h5 class="text-muted">폴더가 비어있습니다</h5>
                            <p class="text-muted">파일을 업로드하거나 새 폴더를 만들어보세요.</p>
                        </div>
                    </div>
                </div>

            </main>
        </div>
    </div>


    <!-- Create Asset Modal -->
    <div class="modal fade" id="createAssetModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">새 에셋 추가</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="createAssetForm">
                        <!-- 교재 ID (필수) -->
                        <div class="mb-3">
                            <label for="bookId" class="form-label">교재 ID <span class="text-danger">*</span></label>
                            <input type="text" class="form-control" id="bookId" name="book_id" required placeholder="예: J1R, J2O, J1G">
                        </div>

                        <!-- 제목 (필수, 기본값은 파일명) -->
                        <div class="mb-3">
                            <label for="assetTitle" class="form-label">제목 <span class="text-danger">*</span></label>
                            <input type="text" class="form-control" id="assetTitle" name="title" required placeholder="제목을 입력하세요">
                        </div>

                        <!-- 카테고리 (옵션) -->
                        <div class="mb-3">
                            <label for="assetCategory" class="form-label">카테고리</label>
                            <input type="text" class="form-control" id="assetCategory" name="category" placeholder="예: 영어, 과학, 수학">
                        </div>

                        <!-- 표지 이미지 (옵션) -->
                        <div class="mb-3">
                            <label class="form-label">표지 이미지</label>
                            <div class="border rounded p-3">
                                <input type="file" class="form-control mb-2" id="coverImageFile" accept="image/*" onchange="handleCoverImageChange()">
                                <div class="form-text">
                                    <i class="fas fa-info-circle"></i> 
                                    JPG, PNG 형식만 지원됩니다.
                                </div>
                                <div id="coverImagePreview" class="mt-2">
                                </div>
                            </div>
                        </div>

                        <!-- 비디오 영상 (필수) -->
                        <div class="mb-3">
                            <label class="form-label">비디오 영상 <span class="text-danger">*</span></label>
                            <div class="border rounded p-3">
                                <input type="file" class="form-control mb-2" id="videoFile" accept="video/*" required onchange="handleVideoFileChange()">
                                <div class="form-text">
                                    <i class="fas fa-info-circle"></i> 
                                    MP4, AVI, MOV 등의 비디오 파일을 지원합니다.
                                </div>
                                <div id="videoPreview" class="mt-2">
                                </div>
                            </div>
                        </div>

                        <!-- 자막 데이터 (옵션) -->
                        <div class="mb-3">
                            <label class="form-label">자막 데이터</label>
                            <div class="border rounded p-3">
                                <div class="d-flex justify-content-between align-items-center mb-2">
                                    <small class="text-muted">페이지별 문장을 추가하세요</small>
                                    <button type="button" class="btn btn-sm btn-outline-primary" onclick="addSubtitleRow()">
                                        <i class="fas fa-plus"></i> 자막 추가
                                    </button>
                                </div>
                                <div id="subtitleContainer">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Upload Progress Indicator -->
                        <div id="uploadProgressSection" style="display: none;">
                            <div class="border rounded p-3 mb-3">
                                <h6 class="mb-3">업로드 진행 상황</h6>
                                <div class="progress mb-2" style="height: 25px;">
                                    <div id="uploadProgressBar" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%;">
                                        <span id="uploadProgressText">0%</span>
                                    </div>
                                </div>
                                <div class="text-center">
                                    <small id="uploadStatus" class="text-muted">업로드 준비 중...</small>
                                </div>
                                <div class="mt-2">
                                    <small class="text-muted">
                                        <i class="fas fa-info-circle"></i> 업로드 속도: <span id="uploadSpeed">계산 중...</span>
                                    </small>
                                </div>
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">취소</button>
                    <button type="submit" class="btn btn-primary" form="createAssetForm">에셋 추가</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Import Modal -->
    <div class="modal fade" id="importModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">JSON에서 에셋 가져오기</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="importForm">
                        <div class="mb-3">
                            <label for="jsonFile" class="form-label">JSON 파일 선택</label>
                            <input type="file" class="form-control" id="jsonFile" name="file" accept=".json">
                        </div>
                        <div class="mb-3">
                            <label for="jsonContent" class="form-label">또는 JSON 내용 붙여넣기</label>
                            <textarea class="form-control" id="jsonContent" name="json_content" rows="10" placeholder="JSON 내용을 여기에 붙여넣으세요..."></textarea>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">취소</button>
                    <button type="button" class="btn btn-primary" onclick="importAssets()">가져오기</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Cover Image Upload Modal -->
    <div class="modal fade" id="coverImageUploadModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog modal-md">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">커버 이미지 업로드</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <input type="hidden" id="coverBookId" />
                    
                    <div class="mb-3">
                        <label for="coverImageInput" class="form-label">커버 이미지 선택 <span class="text-danger">*</span></label>
                        <input type="file" class="form-control" id="coverImageInput" accept="image/*" onchange="handleCoverImageSelect()">
                        <div class="form-text">
                            <i class="fas fa-info-circle"></i> 
                            JPG, PNG 형식을 지원합니다. 파일명은 자동으로 <strong id="coverFileNamePreview">{교재ID}_cover.png</strong>로 변경됩니다.
                        </div>
                    </div>
                    
                    <div id="coverImagePreviewDiv" class="mt-3" style="display: none;">
                        <h6>미리보기</h6>
                        <img id="coverImagePreviewImg" src="" alt="커버 이미지 미리보기" style="max-width: 100%; max-height: 300px; object-fit: contain;" class="border rounded">
                    </div>
                    
                    <!-- Upload Progress Indicator -->
                    <div id="coverUploadProgressSection" style="display: none;">
                        <div class="border rounded p-3 mt-3">
                            <h6 class="mb-3">업로드 진행 상황</h6>
                            <div class="progress mb-2" style="height: 25px;">
                                <div id="coverUploadProgressBar" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%;">
                                    <span id="coverUploadProgressText">0%</span>
                                </div>
                            </div>
                            <div class="text-center">
                                <small id="coverUploadStatus" class="text-muted">업로드 준비 중...</small>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Sync Status Section -->
                    <div id="coverSyncStatusSection" style="display: none;">
                        <div class="border rounded p-3 mt-3">
                            <h6 class="mb-3">파일 동기화</h6>
                            <div id="coverSyncStatus" class="alert alert-info">
                                파일 동기화 중...
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">취소</button>
                    <button type="button" class="btn btn-primary" id="coverImageUploadBtn" disabled>업로드</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/admin.js"></script>
    <script>
        let currentPath = '';
        let selectedItem = null;
        let currentAssets = []; // 현재 표시 중인 에셋/폴더 목록

        // Utility function to get cookie value
        function getCookie(name) {
            
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) {
                const cookieValue = parts.pop().split(';').shift();
                return cookieValue;
            }
            return null;
        }

        // Mobile navigation functionality
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.querySelector('.sidebar-overlay');
            
            sidebar.classList.toggle('open');
            overlay.classList.toggle('show');
        }

        function closeSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.querySelector('.sidebar-overlay');
            
            sidebar.classList.remove('open');
            overlay.classList.remove('show');
        }

        // Close sidebar when clicking outside or on window resize
        window.addEventListener('resize', function() {
            if (window.innerWidth > 768) {
                closeSidebar();
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            // Check if user is authenticated using auth_status cookie
            const authStatus = getCookie('auth_status');
            if (authStatus !== 'authenticated') {
                window.location.href = '/login';
                return;
            }
            
            // Wait for Bootstrap to be fully loaded
            if (typeof bootstrap === 'undefined') {
                setTimeout(() => {
                    if (typeof bootstrap === 'undefined') {
                        alert('Bootstrap이 로드되지 않았습니다. 페이지를 새로고침해주세요.');
                    }
                }, 1000);
                return;
            }
            
            // 첫 진입 시 서버 캐시 초기화
            initializeCache()
                .then(() => {
                    // 폴더 뷰 초기화
                    loadFolderContents(currentPath);
                })
                .catch(error => {
                    // 폴더 뷰 초기화
                    loadFolderContents(currentPath);
                });
            
            // 헤더의 에셋 추가 버튼 이벤트 리스너
            const addAssetBtn = document.getElementById('addAssetBtn');
            if (addAssetBtn) {
                addAssetBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    // 현재 경로 깊이 확인
                    const pathDepth = currentPath ? currentPath.split('/').filter(p => p).length : 0;
                    
                    // 루트 레벨(depth 0) 또는 두 번째 레벨(depth 1)에서만 허용
                    if (pathDepth === 0 || pathDepth === 1) {
                        // 에셋 생성 모달 표시
                        const modal = new bootstrap.Modal(document.getElementById('createAssetModal'));
                        
                        // 모달 내 경로 표시 업데이트
                        const pathDisplayElement = document.getElementById('currentFolderPath');
                        if (pathDisplayElement) {
                            pathDisplayElement.textContent = currentPath || 'root';
                        }
                        
                        modal.show();
                    } else {
                        alert('에셋은 루트 또는 첫 번째 하위 폴더에서만 추가할 수 있습니다.');
                    }
                });
            }
            
            // Add context menu handler for root and second level
            const folderContents = document.getElementById('folderContents');
            if (folderContents) {
                folderContents.addEventListener('contextmenu', function(e) {
                    // Check if we clicked on empty space or outside hover-zone
                    // Allow context menu on folder/file items but outside hover-zone
                    if (!e.target.closest('.hover-zone')) {
                        // Count path depth (empty = root, one slash = second level)
                        const pathDepth = currentPath ? currentPath.split('/').filter(p => p).length : 0;
                        
                        // Show context menu for root level (depth 0) or second level (depth 1)
                        if (pathDepth === 0 || pathDepth === 1) {
                            e.preventDefault();
                            e.stopPropagation();
                            handleRootContextMenu(e);
                        }
                    }
                });
            }
            
            // Initialize modal event listeners
            initializeModalEventListeners();
            
        });


        function initializeModalEventListeners() {
            // Handle create asset modal
            const createAssetForm = document.getElementById('createAssetForm');
            if (createAssetForm) {
                createAssetForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    if (typeof createAsset === 'function') {
                        createAsset();
                    }
                });
            }

            // Also add click listener to submit button as fallback
            const submitButton = document.querySelector('button[form="createAssetForm"]');
            if (submitButton) {
                submitButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    if (typeof createAsset === 'function') {
                        createAsset();
                    }
                });
            }

            // Handle create asset modal cleanup
            const createModalElement = document.getElementById('createAssetModal');
            if (createModalElement) {
                createModalElement.addEventListener('hidden.bs.modal', function() {
                    // Reset form
                    document.getElementById('createAssetForm').reset();
                    // Clear previews and file inputs
                    document.getElementById('coverImagePreview').innerHTML = '';
                    document.getElementById('videoPreview').innerHTML = '';
                    document.getElementById('coverImageFile').value = '';
                    document.getElementById('videoFile').value = '';
                    // Clear subtitle container
                    document.getElementById('subtitleContainer').innerHTML = '';
                    // Hide progress section
                    document.getElementById('uploadProgressSection').style.display = 'none';
                    // Reset progress bar
                    document.getElementById('uploadProgressBar').style.width = '0%';
                    document.getElementById('uploadProgressText').textContent = '0%';
                    // Reset form opacity
                    document.getElementById('createAssetForm').style.opacity = '1';
                    document.getElementById('createAssetForm').style.pointerEvents = 'auto';
                    // Reset submit button
                    const submitButton = createModalElement.querySelector('button[type="submit"]');
                    if (submitButton) {
                        submitButton.disabled = false;
                        submitButton.innerHTML = '에셋 추가';
                    }
                    // Reset book ID field
                    const bookIdInput = document.getElementById('bookId');
                    if (bookIdInput) {
                        bookIdInput.readOnly = false;
                        bookIdInput.style.backgroundColor = '';
                    }
                });
            }

            // Also handle import modal
            const importModalElement = document.getElementById('importModal');
            if (importModalElement) {
                importModalElement.addEventListener('hidden.bs.modal', function() {
                    
                    // Reset import form
                    const importForm = document.getElementById('importForm');
                    if (importForm) {
                        importForm.reset();
                    }

                    // Clean up any stuck backdrops
                    const backdrops = document.querySelectorAll('.modal-backdrop');
                    backdrops.forEach(backdrop => backdrop.remove());
                    
                    document.body.classList.remove('modal-open');
                    document.body.style.overflow = '';
                    document.body.style.paddingRight = '';
                });
            }
        }



        // Helper function to normalize image URLs
        function normalizeImageUrl(imagePath) {
            if (!imagePath) return '';
            
            // If it's already a full URL (starts with http), return as is
            if (imagePath.startsWith('http://') || imagePath.startsWith('https://')) {
                return imagePath;
            }
            
            // If it starts with /assets, return as is
            if (imagePath.startsWith('/assets')) {
                return imagePath;
            }
            
            // If it starts with assets/, add leading slash
            if (imagePath.startsWith('assets/')) {
                return '/' + imagePath;
            }
            
            // Otherwise, assume it's a relative path in assets folder
            return '/assets/' + imagePath;
        }

        function loadAssets() {
            loadFolderContents(currentPath);
        }

        function loadFolderContents(path = '') {
            // Don't encode the path - let the server handle it as is
            const apiUrl = path ? `/api/folders/${path}` : '/api/folders';
            
            // 로딩 상태 표시
            showLoadingState();
            
            API.get(apiUrl)
                .then(data => {
                    hideLoadingState();
                    renderFolderView(data);
                    updateBreadcrumbs(data.breadcrumbs);
                    updateItemCount(data.items.length);
                    
                    // Apply filter if search term exists
                    const searchTerm = document.getElementById('searchInput').value.trim();
                    if (searchTerm) {
                        filterItems();
                    }
                })
                .catch(error => {
                    hideLoadingState();
                    Notification.error('폴더 내용을 불러오는데 실패했습니다: ' + error.message);
                });
        }
        
        function showLoadingState() {
            document.getElementById('loadingIndicator').style.display = 'block';
            document.getElementById('folderContents').style.display = 'none';
            document.getElementById('emptyState').style.display = 'none';
        }
        
        function hideLoadingState() {
            document.getElementById('loadingIndicator').style.display = 'none';
            document.getElementById('folderContents').style.display = 'grid';
        }

        function renderFolderView(data) {
            const folderContents = document.getElementById('folderContents');
            const emptyState = document.getElementById('emptyState');
            
            // currentAssets 전역 변수에 데이터 저장
            currentAssets = data.items || [];
            
            if (!currentAssets || currentAssets.length === 0) {
                folderContents.innerHTML = '';
                emptyState.style.display = 'block';
                return;
            }
            
            emptyState.style.display = 'none';
            folderContents.innerHTML = '';
            
            currentAssets.forEach(item => {
                const itemElement = createItemElement(item);
                folderContents.appendChild(itemElement);
            });
            
            // 모든 아이콘에 스타일 강제 적용
            setTimeout(() => {
                enforceIconStyles();
            }, 100);
        }

        function createItemElement(item) {
            const div = document.createElement('div');
            div.className = item.item_type === 'folder' ? 'folder-item' : 'file-item';
            div.dataset.path = item.path;
            div.dataset.type = item.item_type;
            
            // Add special class for MP4 files
            if (item.item_type === 'file' && item.name && item.name.toLowerCase().endsWith('.mp4')) {
                div.classList.add('playable-video');
            }
            
            const icon = getItemIcon(item);
            const details = getItemDetails(item);
            
            // Add play icon overlay for MP4 files
            const playOverlay = (item.item_type === 'file' && item.name && item.name.toLowerCase().endsWith('.mp4')) 
                ? '<div class="play-overlay"><i class="fas fa-play-circle"></i></div>' 
                : '';
            
            div.innerHTML = `
                <div class="hover-zone"></div>
                <div class="item-icon ${getIconClass(item)}">${icon}${playOverlay}</div>
                <div class="item-name" title="${item.name}">${item.name}</div>
                ${details ? `<div class="item-details">${details}</div>` : ''}
            `;
            
            // hover-zone에 이벤트 리스너 추가
            setTimeout(() => {
                const hoverZone = div.querySelector('.hover-zone');
                if (hoverZone) {
                    // 클릭 이벤트 - hover-zone 클릭 시
                    hoverZone.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        handleItemClick(item);
                    });
                    
                    // 더블클릭 이벤트 - hover-zone 더블클릭 시
                    hoverZone.addEventListener('dblclick', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        handleItemDoubleClick(item);
                    });
                    
                    // 우클릭 컨텍스트 메뉴 - hover-zone 우클릭 시만 발생
                    hoverZone.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        handleContextMenu(e, item);
                    });
                }
            }, 0);
            
            // 전체 div에 대한 클릭은 선택만 처리
            div.addEventListener('click', (e) => {
                // hover-zone이 아닌 영역 클릭 시에만
                if (!e.target.closest('.hover-zone')) {
                    e.preventDefault();
                    e.stopPropagation();
                    handleItemClick(item);
                }
            });
            
            // 아이콘 및 하위 요소 클릭 방지 - 더 강화된 방법
            const iconElement = div.querySelector('.item-icon');
            if (iconElement) {
                iconElement.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                });
                
                // 아이콘 내부의 모든 자식 요소에도 적용
                const iconChildren = iconElement.querySelectorAll('*');
                iconChildren.forEach(child => {
                    child.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    });
                });
            }
            
            return div;
        }
        
        // 모든 아이템 아이콘에 올바른 스타일 강제 적용
        function enforceIconStyles() {
            const allIcons = document.querySelectorAll('.item-icon, .item-icon i');
            allIcons.forEach(icon => {
                if (icon.classList.contains('item-icon')) {
                    // 아이콘 컨테이너
                    icon.style.fontSize = '2rem';
                    icon.style.height = '40px';
                    icon.style.width = '40px';
                    icon.style.display = 'flex';
                    icon.style.justifyContent = 'center';
                    icon.style.alignItems = 'center';
                    icon.style.margin = '0 auto 8px auto';
                    icon.style.pointerEvents = 'none';
                    icon.style.userSelect = 'none';
                } else {
                    // FontAwesome 아이콘
                    icon.style.fontSize = '2rem';
                    icon.style.pointerEvents = 'none';
                    icon.style.userSelect = 'none';
                }
            });
            
            // 모바일에서는 더 작게
            if (window.innerWidth <= 576) {
                allIcons.forEach(icon => {
                    if (icon.classList.contains('item-icon')) {
                        icon.style.fontSize = '1.8rem';
                        icon.style.height = '35px';
                        icon.style.width = '35px';
                    } else {
                        icon.style.fontSize = '1.8rem';
                    }
                });
            }
        }

        function getItemIcon(item) {
            if (item.item_type === 'folder') {
                return '<i class="fas fa-folder"></i>';
            }
            
            switch (item.file_type) {
                case 'image':
                    return '<i class="fas fa-file-image"></i>';
                case 'video':
                    return '<i class="fas fa-file-video"></i>';
                case 'pdf':
                    return '<i class="fas fa-file-pdf"></i>';
                case 'text':
                    return '<i class="fas fa-file-alt"></i>';
                default:
                    return '<i class="fas fa-file"></i>';
            }
        }

        function getIconClass(item) {
            if (item.item_type === 'folder') {
                return 'folder-icon';
            }
            
            switch (item.file_type) {
                case 'image':
                    return 'image-icon';
                case 'video':
                    return 'video-icon';
                case 'pdf':
                    return 'pdf-icon';
                case 'text':
                    return 'text-icon';
                default:
                    return '';
            }
        }

        function getItemDetails(item) {
            if (item.item_type === 'folder') {
                return item.children_count ? `${item.children_count} items` : '';
            }
            
            if (item.size) {
                return formatFileSize(item.size);
            }
            
            return '';
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function handleItemClick(item) {
            // 파일인 경우 적절한 URL로 이동
            if (item.item_type === 'file') {
                // 경로에서 교재 ID와 제목 추출
                const pathParts = item.path.split('/');
                let targetUrl;
                
                if (pathParts.length >= 3) {
                    // 세 번째 뎁스: 교재ID/제목/파일
                    const bookId = pathParts[0];
                    const title = pathParts[1];
                    const fileName = item.name;
                    
                    // 영상 파일인지 확인
                    const isVideoFile = item.name.toLowerCase().match(/\.(mp4|mov|avi|mkv|wmv|flv|webm)$/);
                    
                    if (isVideoFile) {
                        // 영상 파일은 player 경로 사용
                        targetUrl = `https://reengki-assets-r2-worker.reengkigo.workers.dev/player/${bookId}/${title}/${fileName}`;
                    } else {
                        // 기타 파일은 content 경로 사용
                        targetUrl = `https://reengki-assets-r2-worker.reengkigo.workers.dev/content/${bookId}/${title}/${fileName}`;
                    }
                } else if (pathParts.length == 2) {
                    // 두 번째 뎁스: 교재ID/파일 (예: U2R/U2R_cover.png)
                    const bookId = pathParts[0];
                    const fileName = item.name;
                    
                    // 교재 레벨 파일은 content 경로로 바로 접근
                    targetUrl = `https://reengki-assets-r2-worker.reengkigo.workers.dev/content/${bookId}/${fileName}`;
                } else {
                    console.warn('Unexpected file path structure:', item.path);
                    return;
                }
                
                window.open(targetUrl, '_blank');
                return;
            }
            
            // 기존 선택 로직 (폴더나 영상 파일의 경우)
            const previouslySelected = document.querySelector('.folder-item.selected, .file-item.selected');
            if (previouslySelected) {
                previouslySelected.classList.remove('selected');
            }
            
            // 현재 아이템 선택
            const element = document.querySelector(`[data-path="${item.path}"]`);
            if (selectedItem && selectedItem.path === item.path) {
                // 이미 선택된 아이템을 다시 클릭하면 선택 해제
                selectedItem = null;
            } else {
                // 새 아이템 선택
                element.classList.add('selected');
                selectedItem = item;
            }
        }

        function handleItemDoubleClick(item) {
            if (item.item_type === 'folder') {
                navigateToFolder(item.path);
            } else if (item.item_type === 'file' && item.name && item.name.toLowerCase().endsWith('.mp4')) {
                // For MP4 files, open the player
                // Extract book_id from the path (assuming path format: book_id/filename.mp4)
                const pathParts = item.path.split('/');
                if (pathParts.length >= 2) {
                    const bookId = pathParts[0];
                    // Remove .mp4 extension from filename for the title
                    const title = item.name.replace(/\.mp4$/i, '');
                    const playerUrl = `https://reengki-assets-r2-worker.reengkigo.workers.dev/player/${bookId}/${title}/${title}.mp4`;
                    window.open(playerUrl, '_blank');
                } else {
                    Notification.warning('MP4 파일의 경로가 올바르지 않습니다.');
                }
            } else if (item.url) {
                window.open(item.url, '_blank');
            }
        }

        function navigateToFolder(path) {
            currentPath = path;
            loadFolderContents(path);
        }

        function updateBreadcrumbs(breadcrumbs) {
            const breadcrumbNav = document.getElementById('breadcrumbNav');
            breadcrumbNav.innerHTML = '';
            
            breadcrumbs.forEach((crumb, index) => {
                const li = document.createElement('li');
                li.className = 'breadcrumb-item';
                
                if (index === breadcrumbs.length - 1) {
                    li.classList.add('active');
                    li.textContent = crumb.name;
                } else {
                    const a = document.createElement('a');
                    a.href = '#';
                    a.textContent = crumb.name;
                    a.addEventListener('click', (e) => {
                        e.preventDefault();
                        navigateToFolder(crumb.path);
                    });
                    li.appendChild(a);
                }
                
                breadcrumbNav.appendChild(li);
            });
        }

        function updateItemCount(count) {
            const itemCount = document.getElementById('itemCount');
            itemCount.textContent = `${count} items`;
        }


        function refreshAssets() {
            // Show loading state for refresh button
            const refreshButton = document.querySelector('button[onclick="refreshAssets()"]');
            if (refreshButton) {
                refreshButton.disabled = true;
                const originalContent = refreshButton.innerHTML;
                refreshButton.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>새로고침';
                
                // 전체 캐시 갱신 후 새로고침
                clearAllCache()
                    .then(() => {
                        loadAssets();
                    })
                    .catch(error => {
                        loadAssets();
                    })
                    .finally(() => {
                        // loadAssets will show the main loading indicator, so re-enable button after a short delay
                        setTimeout(() => {
                            refreshButton.disabled = false;
                            refreshButton.innerHTML = originalContent;
                        }, 1000);
                    });
            } else {
                // 버튼이 없을 때는 바로 실행
                clearAllCache()
                    .then(() => loadAssets())
                    .catch(error => {
                        loadAssets();
                    });
            }
        }

        // 캐시 관리 함수들
        
        // 첫 진입 시 서버 캐시 초기화
        async function initializeCache() {
            try {
                const response = await fetch('/api/cache/clear', {
                    method: 'POST',
                    credentials: 'include',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                } else {
                }
            } catch (error) {
                throw error;
            }
        }
        
        // 전체 캐시 갱신 (새로고침 시)
        async function clearAllCache() {
            try {
                const response = await fetch('/api/cache/clear', {
                    method: 'POST',
                    credentials: 'include',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                } else {
                }
            } catch (error) {
                throw error;
            }
        }

        // 업로드 시 로컬 캐시에 수동 반영
        function addToLocalCache(assetId, uploadedFiles) {
            
            // asset_id에서 path 정보 추출
            const parts = assetId.split('_');
            if (parts.length < 2) {
                return;
            }
            
            const bookId = parts[0];
            const title = parts.slice(1).join('_');
            const folderPath = `${bookId}/${title}`;
            
            // 업로드된 파일들을 R2WorkerFileItem 형식으로 변환
            const now = new Date().toISOString();
            const newItems = uploadedFiles.map(file => ({
                key: folderPath + '/' + file.filename,
                value: {
                    file: file.file || file.filename,
                    original_file: file.filename,
                    size: file.size || 0,
                    subtitle: [],
                    modifiedDate: now,
                    createDate: now
                }
            }));
            
            // 현재 표시 중인 경로가 업로드된 경로와 같으면 즉시 UI 업데이트
            if (currentPath === folderPath) {
                
                // 현재 assets 배열에 추가
                newItems.forEach(item => {
                    const fileItem = {
                        name: item.value.original_file,
                        path: item.key,
                        item_type: 'file',
                        size: item.value.size,
                        file_type: getFileTypeFromName(item.value.original_file),
                        url: `https://r2-api.reengki.com/file?key=${item.key}`,
                        modified_at: item.value.modifiedDate,
                        children_count: null
                    };
                    
                    currentAssets.push(fileItem);
                });
                
                // 이름 순으로 정렬
                currentAssets.sort((a, b) => a.name.localeCompare(b.name));
                
                // UI 업데이트 (폴더 뷰로 다시 렌더링)
                renderFolderView({ items: currentAssets });
                updateItemCount(currentAssets.length);
                
                // 아이콘 스타일 강제 적용
                setTimeout(() => {
                    enforceIconStyles();
                }, 150);
                
            } else if (currentPath === bookId) {
                // book_id 레벨에서 업로드했으면 새 폴더 추가
                const existingFolder = currentAssets.find(item => 
                    item.item_type === 'folder' && item.name === title
                );
                
                if (!existingFolder) {
                    const folderItem = {
                        name: title,
                        path: folderPath,
                        item_type: 'folder',
                        size: null,
                        file_type: null,
                        url: null,
                        modified_at: now,
                        children_count: newItems.length
                    };
                    
                    currentAssets.push(folderItem);
                    currentAssets.sort((a, b) => a.name.localeCompare(b.name));
                    
                    renderFolderView({ items: currentAssets });
                    updateItemCount(currentAssets.length);
                    
                    // 아이콘 스타일 강제 적용
                    setTimeout(() => {
                        enforceIconStyles();
                    }, 150);
                    
                }
            } else if (currentPath === '') {
                // 루트 레벨에서 업로드했으면 book_id 폴더 추가
                const existingFolder = currentAssets.find(item => 
                    item.item_type === 'folder' && item.name === bookId
                );
                
                if (!existingFolder) {
                    const folderItem = {
                        name: bookId,
                        path: bookId,
                        item_type: 'folder',
                        size: null,
                        file_type: null,
                        url: null,
                        modified_at: now,
                        children_count: null
                    };
                    
                    currentAssets.push(folderItem);
                    currentAssets.sort((a, b) => a.name.localeCompare(b.name));
                    
                    renderFolderView({ items: currentAssets });
                    updateItemCount(currentAssets.length);
                    
                    // 아이콘 스타일 강제 적용
                    setTimeout(() => {
                        enforceIconStyles();
                    }, 150);
                    
                }
            }
        }
        
        // 파일명에서 파일 타입 판단
        function getFileTypeFromName(filename) {
            const lower = filename.toLowerCase();
            if (lower.endsWith('.png') || lower.endsWith('.jpg') || lower.endsWith('.jpeg') || lower.endsWith('.gif') || lower.endsWith('.webp')) {
                return 'image';
            } else if (lower.endsWith('.mp4') || lower.endsWith('.mov') || lower.endsWith('.avi') || lower.endsWith('.mkv') || lower.endsWith('.webm')) {
                return 'video';
            } else if (lower.endsWith('.pdf')) {
                return 'pdf';
            } else if (lower.endsWith('.txt') || lower.endsWith('.json') || lower.endsWith('.xml') || lower.endsWith('.csv')) {
                return 'text';
            } else {
                return 'other';
            }
        }

        function filterItems() {
            const searchTerm = document.getElementById('searchInput').value.trim().toLowerCase();
            const folderItems = document.querySelectorAll('.folder-item, .file-item');
            const clearBtn = document.getElementById('clearSearchBtn');
            let visibleCount = 0;
            
            // Show/hide clear button
            clearBtn.style.display = searchTerm ? '' : 'none';
            
            // If no search term, show all items
            if (!searchTerm) {
                folderItems.forEach(item => {
                    item.style.display = '';
                    visibleCount++;
                });
                updateItemCount(visibleCount);
                return;
            }
            
            // Filter items based on search term
            folderItems.forEach(item => {
                const itemName = item.querySelector('.item-name');
                if (itemName) {
                    const name = itemName.textContent.toLowerCase();
                    if (name.includes(searchTerm)) {
                        item.style.display = '';
                        visibleCount++;
                    } else {
                        item.style.display = 'none';
                    }
                }
            });
            
            // Update item count
            updateItemCount(visibleCount);
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';
            filterItems();
        }

        function handleSearchKeydown(event) {
            if (event.key === 'Escape') {
                clearSearch();
            }
        }

        function searchFiles() {
            // This function is kept for the search button
            filterItems();
        }


        async function exportFolderVideosAsCSV(folder) {
            try {
                // Show loading notification
                Notification.info('비디오 파일 목록을 수집 중입니다...');
                
                // Recursively collect all video files
                const videos = [];
                await collectVideosRecursively(folder.path, videos);
                
                if (videos.length === 0) {
                    Notification.warning('내보낼 비디오 파일이 없습니다.');
                    return;
                }
                
                // Create CSV content
                const csvContent = createVideoCSV(videos);
                
                // Download CSV file
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `${folder.name}_videos_${new Date().toISOString().split('T')[0]}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                Notification.success(`${videos.length}개의 비디오 링크를 내보냈습니다.`);
            } catch (error) {
                Notification.error('내보내기 중 오류가 발생했습니다: ' + error.message);
            }
        }
        
        async function collectVideosRecursively(path, videos) {
            try {
                const apiUrl = `/api/folders/${encodeURIComponent(path)}`;
                const response = await API.get(apiUrl);
                
                if (response && response.items) {
                    for (const item of response.items) {
                        if (item.item_type === 'folder') {
                            // Recursively collect from subfolders
                            await collectVideosRecursively(item.path, videos);
                        } else if (item.item_type === 'file' && item.name && item.name.toLowerCase().endsWith('.mp4')) {
                            // Extract book_id and title
                            const pathParts = item.path.split('/');
                            if (pathParts.length >= 2) {
                                const bookId = pathParts[0];
                                const title = item.name.replace(/\.mp4$/i, '');
                                const videoLink = `https://reengki-assets-r2-worker.reengkigo.workers.dev/player/${bookId}/${title}/${title}.mp4`;
                                
                                videos.push({
                                    bookId: bookId,
                                    title: title,
                                    videoLink: videoLink
                                });
                            }
                        }
                    }
                }
            } catch (error) {
                throw error;
            }
        }
        
        function createVideoCSV(videos) {
            // CSV header
            let csv = '\uFEFF교재 ID,제목,비디오 링크\n';
            
            // Add video data
            videos.forEach(video => {
                // Escape commas and quotes in fields
                const bookId = escapeCSVField(video.bookId);
                const title = escapeCSVField(video.title);
                const videoLink = escapeCSVField(video.videoLink);
                
                csv += `${bookId},${title},${videoLink}\n`;
            });
            
            return csv;
        }
        
        function escapeCSVField(field) {
            if (field.includes(',') || field.includes('"') || field.includes('\n')) {
                return `"${field.replace(/"/g, '""')}"`;
            }
            return field;
        }
        
        // Export subtitles as CSV
        async function exportFolderSubtitlesAsCSV(folder) {
            try {
                // Show loading notification
                Notification.info('자막 데이터를 수집 중입니다...');
                
                // Recursively collect all subtitle data
                const subtitles = [];
                await collectSubtitlesRecursively(folder.path, subtitles);
                
                if (subtitles.length === 0) {
                    Notification.warning('내보낼 자막 데이터가 없습니다.');
                    return;
                }
                
                // Create CSV content
                const csvContent = createSubtitleCSV(subtitles);
                
                // Download CSV file
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `${folder.name}_subtitles_${new Date().toISOString().split('T')[0]}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                Notification.success(`${subtitles.length}개의 자막 항목을 내보냈습니다.`);
            } catch (error) {
                Notification.error('자막 내보내기 중 오류가 발생했습니다: ' + error.message);
            }
        }
        
        async function collectSubtitlesRecursively(path, subtitles) {
            try {
                const apiUrl = `/api/folders/${encodeURIComponent(path)}`;
                const response = await API.get(apiUrl);
                
                if (response && response.items) {
                    for (const item of response.items) {
                        if (item.item_type === 'folder') {
                            // For each folder, try to get subtitle data
                            const pathParts = item.path.split('/');
                            if (pathParts.length >= 2) {
                                const bookId = pathParts[0];
                                const title = pathParts[1];
                                
                                try {
                                    const subtitleResponse = await API.get(`/api/subtitle/${bookId}/${title}`);
                                    if (subtitleResponse.success && subtitleResponse.data && Array.isArray(subtitleResponse.data)) {
                                        subtitleResponse.data.forEach(subtitleItem => {
                                            subtitles.push({
                                                bookId: bookId,
                                                title: title,
                                                pageNum: subtitleItem.page_num || 1,
                                                sentenceNum: subtitleItem.sentence_num || 1,
                                                text: subtitleItem.text || ''
                                            });
                                        });
                                    }
                                } catch (subtitleError) {
                                    // Skip folders without subtitle data
                                    console.log(`No subtitle data for ${bookId}/${title}:`, subtitleError.message);
                                }
                            }
                            
                            // Recursively collect from subfolders
                            await collectSubtitlesRecursively(item.path, subtitles);
                        }
                    }
                }
            } catch (error) {
                throw error;
            }
        }
        
        function createSubtitleCSV(subtitles) {
            // CSV header with BOM for proper UTF-8 encoding
            let csv = '\uFEFF교재ID,제목,페이지번호,문장번호,문장\n';
            
            // Sort subtitles by bookId, title, pageNum, sentenceNum
            subtitles.sort((a, b) => {
                if (a.bookId !== b.bookId) return a.bookId.localeCompare(b.bookId);
                if (a.title !== b.title) return a.title.localeCompare(b.title);
                if (a.pageNum !== b.pageNum) return a.pageNum - b.pageNum;
                return a.sentenceNum - b.sentenceNum;
            });
            
            // Add subtitle data
            subtitles.forEach(subtitle => {
                // Escape CSV fields
                const bookId = escapeCSVField(subtitle.bookId.toString());
                const title = escapeCSVField(subtitle.title.toString());
                const pageNum = subtitle.pageNum;
                const sentenceNum = subtitle.sentenceNum;
                const text = escapeCSVField(subtitle.text.toString());
                
                csv += `${bookId},${title},${pageNum},${sentenceNum},${text}\n`;
            });
            
            return csv;
        }

        function deleteItemWithConfirm(item) {
            const itemType = item.item_type === 'folder' ? '폴더' : '파일';
            const message = item.item_type === 'folder' 
                ? `'${item.name}' 폴더를 삭제하시겠습니까?\n폴더 내의 모든 파일도 함께 삭제됩니다.`
                : `'${item.name}' 파일을 삭제하시겠습니까?`;
            
            if (confirm(message)) {
                deleteItem(item);
            }
        }
        
        async function deleteItem(item) {
            try {
                const response = await API.post('/api/delete-item', {
                    key: item.path
                });
                
                if (response.success) {
                    // 성공시 UI 업데이트
                    Notification.success(`${item.name}이(가) 삭제되었습니다.`);
                    
                    // 목록 새로고침
                    loadFolderContents(currentPath);
                } else {
                    throw new Error(response.error || '삭제 실패');
                }
                
            } catch (error) {
                Notification.error(`삭제 중 오류가 발생했습니다: ${error.message}`);
            }
        }

        function handleContextMenu(e, item) {
            e.preventDefault();
            
            // 기존 컨텍스트 메뉴 제거
            const existingMenu = document.querySelector('.context-menu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            // 컨텍스트 메뉴 생성
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = e.pageX + 'px';
            menu.style.top = e.pageY + 'px';
            
            // 두번째 뎁스 폴더인 경우 수정 메뉴 추가
            const pathDepth = currentPath ? currentPath.split('/').filter(p => p).length : 0;
            if (item.item_type === 'folder' && pathDepth === 1) {
                const infoItem = document.createElement('div');
                infoItem.className = 'context-menu-item';
                infoItem.innerHTML = '<i class="fas fa-edit text-info me-2"></i>수정';
                infoItem.onclick = () => {
                    menu.remove();
                    showFolderInfoPanel(item);
                };
                menu.appendChild(infoItem);
            }
            
            // 최상위 폴더인 경우 내보내기 메뉴 추가
            if (item.item_type === 'folder' && currentPath === '') {
                const exportVideoItem = document.createElement('div');
                exportVideoItem.className = 'context-menu-item';
                exportVideoItem.innerHTML = '<i class="fas fa-video text-primary me-2"></i>비디오 링크 내보내기';
                exportVideoItem.onclick = () => {
                    menu.remove();
                    exportFolderVideosAsCSV(item);
                };
                menu.appendChild(exportVideoItem);
                
                const exportSubtitleItem = document.createElement('div');
                exportSubtitleItem.className = 'context-menu-item';
                exportSubtitleItem.innerHTML = '<i class="fas fa-closed-captioning text-success me-2"></i>자막 정보 내보내기';
                exportSubtitleItem.onclick = () => {
                    menu.remove();
                    exportFolderSubtitlesAsCSV(item);
                };
                menu.appendChild(exportSubtitleItem);
            }
            
            // 삭제 메뉴 아이템
            const deleteItem = document.createElement('div');
            deleteItem.className = 'context-menu-item';
            deleteItem.innerHTML = '<i class="fas fa-trash text-danger me-2"></i>삭제';
            deleteItem.onclick = () => {
                menu.remove();
                deleteItemWithConfirm(item);
            };
            menu.appendChild(deleteItem);
            
            // 메뉴를 body에 추가
            document.body.appendChild(menu);
            
            // 다른 곳 클릭시 메뉴 닫기
            const closeMenu = (event) => {
                if (!menu.contains(event.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            };
            
            // 약간의 지연 후 이벤트 리스너 추가 (즉시 닫히는 것 방지)
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
            }, 100);
        }

        function handleRootContextMenu(e) {
            e.preventDefault();
            
            // 기존 컨텍스트 메뉴 제거
            const existingMenu = document.querySelector('.context-menu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            // 컨텍스트 메뉴 생성
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = e.pageX + 'px';
            menu.style.top = e.pageY + 'px';
            
            // 커버 이미지 추가 메뉴 아이템 (두번째 뎁스에서만)
            const pathDepth = currentPath ? currentPath.split('/').filter(p => p).length : 0;
            if (pathDepth === 1) {
                const bookId = currentPath.split('/').filter(p => p)[0];
                const coverImageName = `${bookId}_cover.png`;
                
                // 현재 폴더의 파일들 중에 커버 이미지가 있는지 확인
                const folderItems = document.querySelectorAll('.file-item[data-type="file"]');
                const hasCoverImage = Array.from(folderItems).some(item => {
                    const itemName = item.querySelector('.item-name')?.textContent?.trim();
                    return itemName === coverImageName;
                });
                
                // 커버 이미지가 없을 때만 '커버 이미지 추가' 메뉴 표시
                if (!hasCoverImage) {
                    const coverItem = document.createElement('div');
                    coverItem.className = 'context-menu-item';
                    coverItem.innerHTML = '<i class="fas fa-image text-success me-2"></i>커버 이미지 추가';
                    coverItem.onclick = () => {
                        menu.remove();
                        showCoverImageUploadModal(bookId);
                    };
                    menu.appendChild(coverItem);
                }
            }

            // 에셋 추가 메뉴 아이템
            const addItem = document.createElement('div');
            addItem.className = 'context-menu-item';
            addItem.innerHTML = '<i class="fas fa-plus text-primary me-2"></i>에셋 추가';
            addItem.onclick = () => {
                menu.remove();
                
                // Get parent folder name if we're in second depth
                let bookId = '';
                
                if (pathDepth === 1) {
                    // Extract the parent folder name as book ID
                    bookId = currentPath.split('/').filter(p => p)[0];
                }
                
                // Show create asset modal
                const modal = new bootstrap.Modal(document.getElementById('createAssetModal'), {
                    backdrop: 'static', // 외부 클릭 시 닫히지 않음
                    keyboard: false     // ESC 키로 닫히지 않음
                });
                modal.show();
                
                // Auto-fill book ID if we're in second depth
                if (bookId) {
                    setTimeout(() => {
                        const bookIdInput = document.getElementById('bookId');
                        if (bookIdInput) {
                            bookIdInput.value = bookId;
                            bookIdInput.readOnly = true;
                            bookIdInput.style.backgroundColor = '#f8f9fa';
                        }
                    }, 100);
                }
            };
            menu.appendChild(addItem);
            
            // 메뉴를 body에 추가
            document.body.appendChild(menu);
            
            // 다른 곳 클릭시 메뉴 닫기
            const closeMenu = (event) => {
                if (!menu.contains(event.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            };
            
            // 약간의 지연 후 이벤트 리스너 추가 (즉시 닫히는 것 방지)
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
            }, 100);
        }


        // Asset creation functions
        let subtitleRowCounter = 0;

        // Handle cover image file change
        function handleCoverImageChange() {
            const fileInput = document.getElementById('coverImageFile');
            const previewDiv = document.getElementById('coverImagePreview');
            const titleInput = document.getElementById('assetTitle');
            
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                
                // Auto-generate title from filename if title is empty
                if (!titleInput.value.trim()) {
                    const filename = file.name;
                    const nameWithoutExtension = filename.substring(0, filename.lastIndexOf('.')) || filename;
                    titleInput.value = nameWithoutExtension;
                }
                
                // Show image preview
                const reader = new FileReader();
                reader.onload = function(e) {
                    previewDiv.innerHTML = `
                        <div class="d-flex align-items-start gap-3 mt-2">
                            <img src="${e.target.result}" alt="표지 미리보기" style="max-width: 200px; max-height: 200px; object-fit: cover;" class="border rounded">
                            <div class="flex-grow-1">
                                <div class="mb-2">
                                    <small class="text-muted">${file.name} (${(file.size/1024/1024).toFixed(2)}MB)</small>
                                </div>
                                <button type="button" class="btn btn-sm btn-outline-danger" onclick="clearCoverImage()">
                                    <i class="fas fa-times"></i> 취소
                                </button>
                            </div>
                        </div>
                    `;
                };
                reader.readAsDataURL(file);
            } else {
                previewDiv.innerHTML = '';
            }
        }
        
        // Clear cover image selection
        function clearCoverImage() {
            const fileInput = document.getElementById('coverImageFile');
            const previewDiv = document.getElementById('coverImagePreview');
            fileInput.value = '';
            previewDiv.innerHTML = '';
        }

        // Handle video file change
        function handleVideoFileChange() {
            const fileInput = document.getElementById('videoFile');
            const previewDiv = document.getElementById('videoPreview');
            
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                
                // Show video info and preview
                const fileSize = (file.size / (1024 * 1024)).toFixed(2); // MB
                const url = URL.createObjectURL(file);
                
                previewDiv.innerHTML = `
                    <div class="d-flex align-items-start gap-3 mt-2">
                        <video controls style="max-width: 300px; max-height: 200px;" class="border rounded">
                            <source src="${url}" type="${file.type}">
                            브라우저가 비디오를 지원하지 않습니다.
                        </video>
                        <div class="flex-grow-1">
                            <div class="mb-2">
                                <small class="text-muted">${file.name} (${fileSize} MB)</small>
                            </div>
                            <button type="button" class="btn btn-sm btn-outline-danger" onclick="clearVideoFile()">
                                <i class="fas fa-times"></i> 취소
                            </button>
                        </div>
                    </div>
                `;
            } else {
                previewDiv.innerHTML = '';
            }
        }
        
        // Clear video file selection
        function clearVideoFile() {
            const fileInput = document.getElementById('videoFile');
            const previewDiv = document.getElementById('videoPreview');
            
            // Clean up object URL if exists
            const video = previewDiv.querySelector('video source');
            if (video && video.src) {
                URL.revokeObjectURL(video.src);
            }
            
            fileInput.value = '';
            previewDiv.innerHTML = '';
        }

        // Add subtitle row
        function addSubtitleRow() {
            subtitleRowCounter++;
            const container = document.getElementById('subtitleContainer');
            
            const row = document.createElement('div');
            row.className = 'subtitle-row mb-2 p-2 border rounded';
            row.id = `subtitle-row-${subtitleRowCounter}`;
            row.innerHTML = `
                <div class="row align-items-center">
                    <div class="col-md-2">
                        <label class="form-label small">페이지</label>
                        <input type="number" class="form-control form-control-sm" name="subtitle_page" min="1" value="1" required>
                    </div>
                    <div class="col-md-2">
                        <label class="form-label small">문장</label>
                        <input type="number" class="form-control form-control-sm" name="subtitle_sentence" min="1" value="1" required>
                    </div>
                    <div class="col-md-7">
                        <label class="form-label small">텍스트</label>
                        <input type="text" class="form-control form-control-sm" name="subtitle_text" placeholder="자막 내용을 입력하세요" required>
                    </div>
                    <div class="col-md-1">
                        <label class="form-label small">&nbsp;</label>
                        <button type="button" class="btn btn-sm btn-outline-danger d-block" onclick="removeSubtitleRow(${subtitleRowCounter})" title="삭제">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
            
            container.appendChild(row);
        }

        // Remove subtitle row
        function removeSubtitleRow(rowId) {
            const row = document.getElementById(`subtitle-row-${rowId}`);
            if (row) {
                row.remove();
            }
        }

        // Helper functions for upload progress
        function updateProgressDisplay(percent, speed, status) {
            const progressBar = document.getElementById('uploadProgressBar');
            const progressText = document.getElementById('uploadProgressText');
            const uploadSpeed = document.getElementById('uploadSpeed');
            const uploadStatus = document.getElementById('uploadStatus');
            
            if (progressBar && progressText && uploadSpeed && uploadStatus) {
                progressBar.style.width = percent + '%';
                progressText.textContent = percent + '%';
                uploadSpeed.textContent = speed;
                uploadStatus.textContent = status;
            }
        }
        
        function resetUploadUI() {
            document.getElementById('uploadProgressSection').style.display = 'none';
            document.getElementById('createAssetForm').style.opacity = '1';
            document.getElementById('createAssetForm').style.pointerEvents = 'auto';
            
            const submitButton = document.querySelector('#createAssetModal button[type=\"submit\"]');
            if (submitButton) {
                submitButton.disabled = false;
                submitButton.innerHTML = '에셋 추가';
            }
            
            // Reset progress values
            updateProgressDisplay(0, '계산 중...', '업로드 준비 중...');
        }
        
        function handleUploadError(message) {
            updateProgressDisplay(0, '오류 발생', message);
            Notification.error(message);
            
            // Reset UI after showing error briefly
            setTimeout(() => {
                resetUploadUI();
            }, 2000);
        }

        // Create asset function with upload progress tracking
        function createAsset() {
            const form = document.getElementById('createAssetForm');
            
            // Validate form
            if (!form.checkValidity()) {
                form.reportValidity();
                return;
            }

            // Get form data
            const bookId = document.getElementById('bookId').value.trim();
            const title = document.getElementById('assetTitle').value.trim();
            const category = document.getElementById('assetCategory').value.trim();
            const coverFile = document.getElementById('coverImageFile').files[0];
            const videoFile = document.getElementById('videoFile').files[0];

            // Collect subtitle data
            const subtitleRows = document.querySelectorAll('.subtitle-row');
            const subtitles = [];
            
            subtitleRows.forEach(row => {
                const page = row.querySelector('[name="subtitle_page"]').value;
                const sentence = row.querySelector('[name="subtitle_sentence"]').value;
                const text = row.querySelector('[name="subtitle_text"]').value.trim();
                
                if (page && sentence && text) {
                    subtitles.push({
                        page_num: parseInt(page),
                        sentence_num: parseInt(sentence),
                        text: text
                    });
                }
            });

            // Validate required fields
            if (!bookId || !title || !videoFile) {
                Notification.error('필수 필드를 모두 입력해주세요. (교재 ID, 제목, 비디오 파일)');
                return;
            }
            
            // Check individual file size limits before upload
            const maxFileSize = 2 * 1024 * 1024 * 1024; // 2GB
            if (videoFile.size > maxFileSize) {
                Notification.error(`비디오 파일이 너무 큽니다: ${(videoFile.size / (1024 * 1024 * 1024)).toFixed(2)}GB (최대 2GB)`);
                return;
            }
            if (coverFile && coverFile.size > maxFileSize) {
                Notification.error(`이미지 파일이 너무 큽니다: ${(coverFile.size / (1024 * 1024 * 1024)).toFixed(2)}GB (최대 2GB)`);
                return;
            }

            // Show upload progress section
            document.getElementById('uploadProgressSection').style.display = 'block';
            
            // Hide form to prevent changes during upload
            document.getElementById('createAssetForm').style.opacity = '0.5';
            document.getElementById('createAssetForm').style.pointerEvents = 'none';

            // Disable submit button
            const submitButton = document.querySelector('#createAssetModal button[type="submit"]');
            submitButton.disabled = true;
            submitButton.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>업로드 중...';

            // Create FormData for multipart upload
            const formData = new FormData();
            formData.append('book_id', bookId);
            formData.append('title', title);
            formData.append('category', category);
            if (coverFile) {
                formData.append('cover_image', coverFile);
            }
            formData.append('video_file', videoFile);
            formData.append('subtitles', JSON.stringify(subtitles));

            // Calculate total file size
            const totalSize = (coverFile ? coverFile.size : 0) + videoFile.size;
            const totalSizeMB = (totalSize / (1024 * 1024)).toFixed(2);
            document.getElementById('uploadStatus').textContent = `총 ${totalSizeMB}MB 업로드 중...`;

            // Track upload progress
            const startTime = Date.now();
            let lastLoaded = 0;
            let uploadPhase = 'uploading'; // 'uploading', 'processing', 'completed'
            let maxProgressReached = 0;

            // Create XMLHttpRequest for progress tracking
            const xhr = new XMLHttpRequest();
            
            // Set timeout to 10 minutes for large files
            xhr.timeout = 600000; // 600 seconds = 10 minutes
            
            // Initialize progress display
            updateProgressDisplay(0, 'upload', '업로드 시작 중...');
            
            // Add timeout handler
            xhr.addEventListener('timeout', function() {
                handleUploadError('업로드 시간 초과 (10분). 파일이 너무 크거나 네트워크가 느립니다.');
            });

            // Update progress during upload
            xhr.upload.addEventListener('progress', function(e) {
                if (e.lengthComputable && uploadPhase === 'uploading') {
                    // Upload progress should only go up to 95% to leave room for server processing
                    const uploadProgress = Math.min(Math.round((e.loaded / e.total) * 95), 95);
                    maxProgressReached = Math.max(maxProgressReached, uploadProgress);
                    
                    // Calculate upload speed
                    const currentTime = Date.now();
                    const elapsedTime = (currentTime - startTime) / 1000; // seconds
                    const bytesPerSecond = e.loaded / elapsedTime;
                    const speedMBps = (bytesPerSecond / (1024 * 1024)).toFixed(2);
                    
                    // Update status text
                    const uploadedMB = (e.loaded / (1024 * 1024)).toFixed(2);
                    const remainingTime = Math.round((e.total - e.loaded) / bytesPerSecond);
                    const remainingMinutes = Math.floor(remainingTime / 60);
                    const remainingSeconds = remainingTime % 60;
                    
                    let statusText = `${uploadedMB}MB / ${totalSizeMB}MB 업로드 중`;
                    if (remainingTime > 0 && e.loaded < e.total) {
                        statusText += ` - 남은 시간: ${remainingMinutes}분 ${remainingSeconds}초`;
                    }
                    
                    updateProgressDisplay(uploadProgress, speedMBps + ' MB/s', statusText);
                    
                }
            });
            
            // Handle upload completion (data sent to server)
            xhr.upload.addEventListener('load', function() {
                uploadPhase = 'processing';
                updateProgressDisplay(96, '처리 중...', '서버에서 파일을 처리하고 있습니다...');
            });

            // Handle server response
            xhr.addEventListener('load', function() {
                
                if (xhr.status === 200) {
                    try {
                        const data = JSON.parse(xhr.responseText);
                        if (data.success) {
                            // Show completion
                            uploadPhase = 'completed';
                            updateProgressDisplay(100, '완료!', '에셋이 성공적으로 추가되었습니다!');
                            
                            // Wait a bit to show completion, then hide
                            setTimeout(() => {
                                Notification.success('에셋이 성공적으로 추가되었습니다!');
                                
                                // Reset form
                                form.reset();
                                document.getElementById('coverImagePreview').innerHTML = '';
                                document.getElementById('videoPreview').innerHTML = '';
                                document.getElementById('subtitleContainer').innerHTML = '';
                                
                                // Hide modal
                                const modalElement = document.getElementById('createAssetModal');
                                const modalInstance = bootstrap.Modal.getInstance(modalElement);
                                if (modalInstance) {
                                    modalInstance.hide();
                                }
                                
                                // 업로드 완료 후 로컬 캐시에 수동 반영
                                
                                // 업로드 응답에서 파일 정보 추출 (xhr.responseText에서 전체 업로드 응답 파싱)
                                let uploadedFiles = [];
                                try {
                                    const fullResponse = JSON.parse(xhr.responseText);
                                    // 실제 파일 정보는 별도 API 호출 결과에 있을 것으로 예상, 일단 기본 정보로 추가
                                    const parts = data.asset_id.split('_');
                                    const title = parts.slice(1).join('_');
                                    
                                    // 폼에서 업로드한 파일들 정보 수집
                                    const formData = new FormData(form);
                                    const coverFile = formData.get('cover_image');
                                    const videoFile = formData.get('video_file');
                                    
                                    if (coverFile && coverFile.size > 0) {
                                        uploadedFiles.push({
                                            filename: `${title}.${coverFile.name.split('.').pop()}`,
                                            original_file: `${title}.${coverFile.name.split('.').pop()}`,
                                            size: coverFile.size,
                                            file: `${title}.${coverFile.name.split('.').pop()}`
                                        });
                                    }
                                    
                                    if (videoFile && videoFile.size > 0) {
                                        uploadedFiles.push({
                                            filename: `${title}.${videoFile.name.split('.').pop()}`,
                                            original_file: `${title}.${videoFile.name.split('.').pop()}`,
                                            size: videoFile.size,
                                            file: `${title}.${videoFile.name.split('.').pop()}`
                                        });
                                    }
                                    
                                    // 자막 파일도 추가
                                    const subtitles = formData.get('subtitles');
                                    if (subtitles && subtitles.trim()) {
                                        uploadedFiles.push({
                                            filename: 'subtitle.json',
                                            original_file: 'subtitle.json',
                                            size: new Blob([subtitles]).size,
                                            file: 'subtitle.json'
                                        });
                                    }
                                } catch (e) {
                                }
                                
                                addToLocalCache(data.asset_id, uploadedFiles);
                                resetUploadUI();
                            }, 1500); // Show success for 1.5 seconds
                        } else {
                            handleUploadError('에셋 추가에 실패했습니다: ' + data.message);
                        }
                    } catch (error) {
                        handleUploadError('서버 응답 처리 중 오류 발생');
                    }
                } else {
                    let errorMessage = '업로드 실패: HTTP ' + xhr.status;
                    if (xhr.status === 413) {
                        errorMessage = '파일 크기 제한 초과 (최대 2GB)';
                    } else if (xhr.status === 408) {
                        errorMessage = '요청 시간 초과. 네트워크 연결을 확인하세요.';
                    } else if (xhr.status === 0) {
                        errorMessage = '서버 연결이 끊어졌습니다. 네트워크를 확인하세요.';
                    }
                    handleUploadError(errorMessage);
                }
            });

            // Handle errors
            xhr.addEventListener('error', function(event) {
                
                let errorMessage = '네트워크 오류가 발생했습니다';
                if (xhr.status === 0) {
                    errorMessage = '서버 연결 실패. 네트워크 연결을 확인하세요.';
                } else if (xhr.status === 413) {
                    errorMessage = '파일이 너무 큽니다. 서버에서 거부되었습니다.';
                } else if (xhr.status >= 500) {
                    errorMessage = '서버 오류가 발생했습니다. 잠시 후 다시 시도하세요.';
                }
                
                handleUploadError(errorMessage);
            });

            // Log upload start
            
            // Send request
            xhr.open('POST', '/api/assets');
            xhr.withCredentials = true;
            
            try {
                xhr.send(formData);
            } catch (error) {
                handleUploadError('업로드 요청 실패: ' + error.message);
            }
        }




        // Import modal is now handled by Bootstrap data attributes

        // Show cover sync status in modal
        function showCoverSyncStatus(message, type) {
            const statusDiv = document.getElementById('coverSyncStatus');
            if (!statusDiv) return;
            
            statusDiv.className = `alert alert-${type}`;
            statusDiv.innerHTML = message;
        }
        
        // Auto-sync after cover image upload
        async function startCoverImageAutoSync(bookId, expectedFileName) {
            let attempts = 0;
            const maxAttempts = 5;
            const checkInterval = 2000; // 2 seconds
            
            const checkFileExists = async () => {
                try {
                    attempts++;
                    console.log(`Cover image sync attempt ${attempts}/${maxAttempts}`);
                    
                    showCoverSyncStatus(`파일 동기화 확인 중... (${attempts}/${maxAttempts})`, 'info');
                    
                    // Clear cache first
                    await clearAllCache();
                    
                    // Check if file exists in folder
                    const response = await fetch(`/api/folders/${bookId}`);
                    const folderData = await response.json();
                    
                    if (folderData.items) {
                        const coverFile = folderData.items.find(item => 
                            item.item_type === 'file' && 
                            (item.name.toLowerCase().includes('cover') && 
                             (item.name.toLowerCase().includes('.png') || item.name.toLowerCase().includes('.jpg')))
                        );
                        
                        if (coverFile) {
                            // File found! Success
                            showCoverSyncStatus('파일 동기화 완료! 폴더를 새로고침합니다.', 'success');
                            
                            setTimeout(() => {
                                loadFolderContents(currentPath);
                                
                                // Close modal after success
                                const modalElement = document.getElementById('coverImageUploadModal');
                                const modalInstance = bootstrap.Modal.getInstance(modalElement);
                                if (modalInstance) {
                                    modalInstance.hide();
                                }
                            }, 1500);
                            
                            return true; // Success
                        }
                    }
                    
                    if (attempts >= maxAttempts) {
                        // Max attempts reached - provide refresh button
                        showCoverSyncStatus(
                            `파일 동기화에 시간이 걸리고 있습니다. <button type="button" class="btn btn-sm btn-primary ms-2" onclick="manualRefreshAfterCoverUpload()">새로고침</button>`, 
                            'warning'
                        );
                        return false; // Failed
                    } else {
                        // Try again after interval
                        setTimeout(checkFileExists, checkInterval);
                        return null; // Continue
                    }
                    
                } catch (error) {
                    console.error('Cover sync check error:', error);
                    if (attempts >= maxAttempts) {
                        showCoverSyncStatus(
                            `동기화 확인 중 오류가 발생했습니다. <button type="button" class="btn btn-sm btn-primary ms-2" onclick="manualRefreshAfterCoverUpload()">새로고침</button>`, 
                            'warning'
                        );
                        return false;
                    } else {
                        setTimeout(checkFileExists, checkInterval);
                        return null;
                    }
                }
            };
            
            // Start checking
            checkFileExists();
        }
        
        // Manual refresh function for cover upload
        function manualRefreshAfterCoverUpload() {
            showCoverSyncStatus('수동 새로고침 중...', 'info');
            
            // Clear cache and refresh
            clearAllCache()
                .then(() => {
                    loadFolderContents(currentPath);
                    showCoverSyncStatus('새로고침 완료!', 'success');
                    
                    setTimeout(() => {
                        const modalElement = document.getElementById('coverImageUploadModal');
                        const modalInstance = bootstrap.Modal.getInstance(modalElement);
                        if (modalInstance) {
                            modalInstance.hide();
                        }
                    }, 1500);
                })
                .catch(() => {
                    loadFolderContents(currentPath);
                    showCoverSyncStatus('새로고침 완료!', 'success');
                    
                    setTimeout(() => {
                        const modalElement = document.getElementById('coverImageUploadModal');
                        const modalInstance = bootstrap.Modal.getInstance(modalElement);
                        if (modalInstance) {
                            modalInstance.hide();
                        }
                    }, 1500);
                });
        }
        
        function importAssets() {
            const fileInput = document.getElementById('jsonFile');
            const textInput = document.getElementById('jsonContent');
            
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const jsonData = JSON.parse(e.target.result);
                        processImportData(jsonData);
                    } catch (error) {
                        Notification.error('잘못된 JSON 파일입니다: ' + error.message);
                    }
                };
                reader.readAsText(file);
            } else if (textInput.value.trim()) {
                try {
                    const jsonData = JSON.parse(textInput.value);
                    processImportData(jsonData);
                } catch (error) {
                    Notification.error('잘못된 JSON 내용입니다: ' + error.message);
                }
            } else {
                Notification.warning('파일을 선택하거나 JSON 내용을 입력해주세요');
            }
        }

        function processImportData(jsonData) {
            API.post('/api/assets', jsonData)
                .then(data => {
                    Notification.success('에셋이 성공적으로 가져와졌습니다!');
                    
                    // Hide the modal
                    const modalElement = document.getElementById('importModal');
                    const modalInstance = bootstrap.Modal.getInstance(modalElement);
                    if (modalInstance) {
                        modalInstance.hide();
                    }
                    
                    document.getElementById('importForm').reset();
                    loadAssets();
                })
                .catch(error => {
                    Notification.error('에셋 가져오기에 실패했습니다: ' + error.message);
                });
        }

        // Cover Image Upload Functions
        window.uploadCoverImageHandler = null;
        
        function showCoverImageUploadModal(bookId) {
            document.getElementById('coverBookId').value = bookId;
            document.getElementById('coverFileNamePreview').textContent = bookId + '_cover.png';
            
            // Reset elements
            document.getElementById('coverImageInput').value = '';
            document.getElementById('coverImagePreviewDiv').style.display = 'none';
            document.getElementById('coverUploadProgressSection').style.display = 'none';
            
            const uploadBtn = document.getElementById('coverImageUploadBtn');
            uploadBtn.disabled = true;
            
            // Remove old handler if exists
            if (window.uploadCoverImageHandler) {
                uploadBtn.removeEventListener('click', window.uploadCoverImageHandler);
            }
            
            // Create new handler
            window.uploadCoverImageHandler = function(e) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                console.log('Upload button clicked - handler');
                
                // Call upload function directly
                const fileInput = document.getElementById('coverImageInput');
                const bookId = document.getElementById('coverBookId').value;
                
                if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
                    Notification.warning('커버 이미지를 선택해주세요');
                    return false;
                }
                
                const file = fileInput.files[0];
                console.log('File selected:', file.name, 'Size:', file.size);
                const formData = new FormData();
                
                // 파일명을 {교재ID}_cover.png로 설정
                const extension = file.name.substring(file.name.lastIndexOf('.')) || '.png';
                const coverFileName = bookId + '_cover' + extension;
                
                // FormData에 파일 추가
                formData.append('file', file, coverFileName);
                // full_path 파라미터 추가 (서버에서 요구함)
                formData.append('full_path', bookId + '/' + coverFileName);
                
                // Progress elements
                const progressSection = document.getElementById('coverUploadProgressSection');
                const progressBar = document.getElementById('coverUploadProgressBar');
                const progressText = document.getElementById('coverUploadProgressText');
                const uploadStatus = document.getElementById('coverUploadStatus');
                const uploadBtnElement = document.getElementById('coverImageUploadBtn');
                
                // Show progress
                progressSection.style.display = 'block';
                uploadBtnElement.disabled = true;
                
                // Create XMLHttpRequest for progress tracking
                const xhr = new XMLHttpRequest();
                
                // Track upload progress
                xhr.upload.addEventListener('progress', function(e) {
                    if (e.lengthComputable) {
                        const percentComplete = Math.round((e.loaded / e.total) * 100);
                        progressBar.style.width = percentComplete + '%';
                        progressText.textContent = percentComplete + '%';
                        uploadStatus.textContent = `업로드 중... (${(e.loaded/1024/1024).toFixed(2)}MB / ${(e.total/1024/1024).toFixed(2)}MB)`;
                    }
                });
                
                // Handle completion
                xhr.addEventListener('load', function() {
                    if (xhr.status === 200 || xhr.status === 201) {
                        try {
                            const response = JSON.parse(xhr.responseText);
                            
                            // Hide upload progress and show sync status
                            document.getElementById('coverUploadProgressSection').style.display = 'none';
                            document.getElementById('coverSyncStatusSection').style.display = 'block';
                            
                            showCoverSyncStatus('커버 이미지가 성공적으로 업로드되었습니다! 파일 동기화 중...', 'info');
                            
                            // Start auto-sync process
                            const bookId = document.getElementById('coverBookId').value;
                            const expectedFileName = `${bookId}_cover.png`;
                            startCoverImageAutoSync(bookId, expectedFileName);
                            
                        } catch (error) {
                            showCoverSyncStatus('업로드 예상치 못한 오류가 발생했습니다.', 'danger');
                        }
                    } else {
                        document.getElementById('coverUploadProgressSection').style.display = 'none';
                        document.getElementById('coverSyncStatusSection').style.display = 'block';
                        showCoverSyncStatus('업로드 실패: ' + xhr.statusText, 'danger');
                    }
                    
                    uploadBtnElement.disabled = false;
                });
                
                // Handle errors
                xhr.addEventListener('error', function() {
                    document.getElementById('coverUploadProgressSection').style.display = 'none';
                    document.getElementById('coverSyncStatusSection').style.display = 'block';
                    showCoverSyncStatus('네트워크 오류가 발생했습니다.', 'danger');
                    uploadBtnElement.disabled = false;
                });
                
                // API endpoint for single file upload
                xhr.open('POST', '/api/upload-file');
                xhr.withCredentials = true;
                
                try {
                    xhr.send(formData);
                } catch (error) {
                    Notification.error('업로드 요청 실패: ' + error.message);
                    uploadBtnElement.disabled = false;
                }
                
                return false;
            };
            
            // Add new handler
            uploadBtn.addEventListener('click', window.uploadCoverImageHandler);
            
            // Reset modal state when showing
            document.getElementById('coverUploadProgressSection').style.display = 'none';
            document.getElementById('coverSyncStatusSection').style.display = 'none';
            document.getElementById('coverImagePreviewDiv').style.display = 'none';
            document.getElementById('coverImageInput').value = '';
            document.getElementById('coverImageUploadBtn').disabled = true;
            
            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('coverImageUploadModal'), {
                backdrop: 'static',
                keyboard: false
            });
            modal.show();
        }

        function handleCoverImageSelect() {
            const fileInput = document.getElementById('coverImageInput');
            const previewDiv = document.getElementById('coverImagePreviewDiv');
            const previewImg = document.getElementById('coverImagePreviewImg');
            const uploadBtn = document.getElementById('coverImageUploadBtn');
            
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                
                // Show preview
                const reader = new FileReader();
                reader.onload = function(e) {
                    previewImg.src = e.target.result;
                    previewDiv.style.display = 'block';
                    uploadBtn.disabled = false;
                };
                reader.readAsDataURL(file);
            } else {
                previewDiv.style.display = 'none';
                uploadBtn.disabled = true;
            }
        }

        function uploadCoverImage() {
            // This function is now handled inline in the event listener above
            console.log('uploadCoverImage function called - deprecated');
        }

        // Refresh folder contents with retry logic (similar to image sync)
        function refreshFolderContentsWithRetry(maxAttempts = 5, checkInterval = 2000) {
            let attempts = 0;
            
            function doRefresh() {
                attempts++;
                console.log(`Refreshing folder contents - attempt ${attempts}/${maxAttempts}`);
                
                try {
                    // Clear cache first
                    clearAllCache()
                        .then(() => {
                            // Load folder contents
                            loadFolderContents(currentPath);
                        })
                        .catch(error => {
                            console.warn('Cache clear failed, refreshing anyway:', error);
                            loadFolderContents(currentPath);
                        });
                    
                    // Schedule next refresh if not the last attempt
                    if (attempts < maxAttempts) {
                        setTimeout(doRefresh, checkInterval);
                    }
                    
                } catch (error) {
                    console.error('Refresh error:', error);
                    
                    // Schedule next refresh if not the last attempt
                    if (attempts < maxAttempts) {
                        setTimeout(doRefresh, checkInterval);
                    }
                }
            }
            
            // Start the refresh cycle
            doRefresh();
        }

        function exportAssets() {
            API.get('/api/assets')
                .then(data => {
                    const jsonData = JSON.stringify(data, null, 2);
                    const blob = new Blob([jsonData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'assets_export_' + new Date().toISOString().split('T')[0] + '.json';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    Notification.success('에셋이 성공적으로 내보내졌습니다!');
                })
                .catch(error => {
                    Notification.error('에셋 내보내기에 실패했습니다: ' + error.message);
                });
        }

        // Removed duplicate uploadCoverImage function

        function uploadVideoImage() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    uploadFile(file, 'video_image', function(response) {
                        document.getElementById('videoImg').value = response.file_path;
                        Notification.success('동영상 썸네일이 성공적으로 업로드되었습니다!');
                    });
                }
            };
            input.click();
        }

        function uploadFile(file, type, callback) {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('type', type);

            fetch('/api/upload', {
                method: 'POST',
                credentials: 'include',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    callback(data);
                } else {
                    Notification.error('업로드 실패: ' + data.message);
                }
            })
            .catch(error => {
                Notification.error('업로드 실패: ' + error.message);
            });
        }

        // Edit Cover Images Functions
        function editCoverImages(assetId) {
            const asset = currentAssets.find(a => a.id === assetId);
            if (!asset) {
                Notification.error('에셋을 찾을 수 없습니다');
                return;
            }

            document.getElementById('editCoverAssetId').value = assetId;
            document.getElementById('editCovers').value = JSON.stringify(asset.covers, null, 2);
            
            // Show cover preview
            updateCoverPreview(asset);
            
            // Reset upload section
            document.getElementById('coverFileInput').value = '';
            document.getElementById('uploadedCoversList').innerHTML = '';
            
            // Setup advanced toggle
            const advancedCheckbox = document.getElementById('showAdvancedCoverEdit');
            const advancedSection = document.getElementById('advancedCoverEdit');
            advancedCheckbox.onchange = function() {
                advancedSection.style.display = this.checked ? 'block' : 'none';
            };

            const modalElement = document.getElementById('editCoverModal');
            const modal = bootstrap.Modal.getOrCreateInstance(modalElement);
            modal.show();
        }

        function updateCoverPreview(asset) {
            const previewDiv = document.getElementById('coverPreview');
            if (!asset.covers || asset.covers.length === 0) {
                previewDiv.innerHTML = '<p class="text-muted">표지 이미지가 없습니다.</p>';
                return;
            }

            const previewHtml = asset.covers.map(cover => `
                <div class="d-inline-block m-2">
                    <img src="/asset/${asset.curriculum}/${asset.month}/${cover}" 
                         alt="표지" 
                         style="width: 100px; height: 100px; object-fit: cover;" 
                         class="border rounded"
                         onerror="this.style.display='none'">
                    <div class="small text-center mt-1">${cover}</div>
                </div>
            `).join('');

            previewDiv.innerHTML = `
                <h6>현재 표지 이미지들:</h6>
                <div>${previewHtml}</div>
            `;
        }

        // Upload cover files function
        function uploadCoverFiles() {
            const fileInput = document.getElementById('coverFileInput');
            const files = fileInput.files;
            
            
            if (files.length === 0) {
                Notification.warning('업로드할 파일을 선택해주세요');
                return;
            }

            const progressDiv = document.getElementById('coverUploadProgress');
            const progressBar = progressDiv.querySelector('.progress-bar');
            const statusDiv = document.getElementById('coverUploadStatus');
            const uploadedList = document.getElementById('uploadedCoversList');
            
            progressDiv.style.display = 'block';
            
            let uploadedFiles = [];
            let completedUploads = 0;
            
            Array.from(files).forEach((file, index) => {
                const formData = new FormData();
                formData.append('file', file);
                
                fetch('/api/upload', {
                    method: 'POST',
                    credentials: 'include',
                    body: formData
                })
                .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
                .then(data => {
                    completedUploads++;
                    const progress = (completedUploads / files.length) * 100;
                    progressBar.style.width = progress + '%';
                    statusDiv.textContent = `업로드 중... ${completedUploads}/${files.length}`;
                    
                    if (data.success) {
                        uploadedFiles.push(data.file_path);
                        
                        // Add to uploaded files list
                        const fileDiv = document.createElement('div');
                        fileDiv.className = 'border rounded p-2 mb-2 d-flex align-items-center justify-content-between';
                        fileDiv.innerHTML = `
                            <div class="d-flex align-items-center">
                                <img src="${data.file_path}" alt="업로드된 이미지" style="width: 50px; height: 50px; object-fit: cover;" class="me-2 rounded">
                                <span>${file.name}</span>
                            </div>
                            <button type="button" class="btn btn-sm btn-outline-danger" onclick="removeCoverFile('${data.file_path}', this)">
                                <i class="fas fa-times"></i>
                            </button>
                        `;
                        uploadedList.appendChild(fileDiv);
                    } else {
                        Notification.error(`${file.name} 업로드 실패: ${data.message}`);
                    }
                    
                    if (completedUploads === files.length) {
                        progressDiv.style.display = 'none';
                        if (uploadedFiles.length > 0) {
                            Notification.success(`${uploadedFiles.length}개 파일이 성공적으로 업로드되었습니다`);
                            
                            // Get current covers to maintain existing filenames (overwrite mode)
                            const currentCovers = JSON.parse(document.getElementById('editCovers').value || '[]');
                            
                            // Replace files but keep the existing filenames exactly as they are
                            // The backend will handle moving uploaded files to overwrite existing ones
                            document.getElementById('editCovers').value = JSON.stringify(currentCovers, null, 2);
                            
                            // Show success message indicating files will be replaced
                        }
                    }
                })
                .catch(error => {
                    completedUploads++;
                    Notification.error(`${file.name} 업로드 실패: ${error.message}`);
                    
                    if (completedUploads === files.length) {
                        progressDiv.style.display = 'none';
                    }
                });
            });
        }
        
        function removeCoverFile(filePath, buttonElement) {
            // Remove from uploaded list
            buttonElement.closest('div').remove();
            
            // Remove from JSON textarea
            const currentCovers = JSON.parse(document.getElementById('editCovers').value || '[]');
            // Extract filename and create cover path
            const filename = filePath.split('/').pop();
            const coverPath = `cover/${filename}`;
            const updatedCovers = currentCovers.filter(cover => cover !== coverPath);
            document.getElementById('editCovers').value = JSON.stringify(updatedCovers, null, 2);
            
            Notification.info('파일이 목록에서 제거되었습니다');
        }

        function saveCoverChanges() {
            const assetId = document.getElementById('editCoverAssetId').value;
            const coversText = document.getElementById('editCovers').value;

            try {
                const covers = JSON.parse(coversText);
                if (!Array.isArray(covers)) {
                    throw new Error('배열 형태가 아닙니다');
                }

                const updateData = {
                    covers: covers
                };

                // Disable save button to prevent double submission
                const saveButton = document.querySelector('#editCoverModal .btn-primary');
                saveButton.disabled = true;
                saveButton.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>저장 중...';

                API.put(`/api/assets/${assetId}`, updateData)
                    .then(data => {
                        Notification.success('표지 이미지가 성공적으로 업데이트되었습니다!');
                        
                        // Hide the modal
                        const modalElement = document.getElementById('editCoverModal');
                        const modalInstance = bootstrap.Modal.getInstance(modalElement);
                        modalInstance.hide();
                        
                        // Refresh the assets list
                        loadAssets();
                    })
                    .catch(error => {
                        Notification.error('표지 이미지 업데이트에 실패했습니다: ' + error.message);
                    })
                    .finally(() => {
                        // Re-enable save button
                        saveButton.disabled = false;
                        saveButton.innerHTML = '저장';
                    });

            } catch (error) {
                Notification.error('잘못된 JSON 형식입니다: ' + error.message);
            }
        }


        // Edit YouTube Links Functions
        function editYouTubeLinks(assetId) {
            const asset = currentAssets.find(a => a.id === assetId);
            if (!asset) {
                Notification.error('에셋을 찾을 수 없습니다');
                return;
            }

            document.getElementById('editYouTubeAssetId').value = assetId;
            document.getElementById('editYouTubeLinks').value = JSON.stringify(asset.youtube_links, null, 2);
            
            // Display current YouTube links for management
            displayCurrentYouTubeLinks(asset.youtube_links, asset);
            
            // Reset form inputs
            document.getElementById('thumbnailFileInput').value = '';
            document.getElementById('youtubeUrl').value = '';
            document.getElementById('youtubeTitle').value = '';
            document.getElementById('thumbnailPreview').innerHTML = '';
            
            // Setup advanced toggle
            const advancedCheckbox = document.getElementById('showAdvancedYouTubeEdit');
            const advancedSection = document.getElementById('advancedYouTubeEdit');
            advancedCheckbox.onchange = function() {
                advancedSection.style.display = this.checked ? 'block' : 'none';
            };
            
            // Setup thumbnail preview
            document.getElementById('thumbnailFileInput').onchange = function() {
                const file = this.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        document.getElementById('thumbnailPreview').innerHTML = `
                            <img src="${e.target.result}" alt="썸네일 미리보기" style="width: 100px; height: 60px; object-fit: cover;" class="border rounded">
                        `;
                    };
                    reader.readAsDataURL(file);
                }
            };

            const modalElement = document.getElementById('editYouTubeModal');
            const modal = bootstrap.Modal.getOrCreateInstance(modalElement);
            modal.show();
        }

        // YouTube preview function removed as requested

        function formatYouTubeJson() {
            const textarea = document.getElementById('editYouTubeLinks');
            try {
                const parsed = JSON.parse(textarea.value);
                textarea.value = JSON.stringify(parsed, null, 2);
                Notification.success('JSON이 포맷팅되었습니다');
            } catch (error) {
                Notification.error('잘못된 JSON 형식입니다: ' + error.message);
            }
        }

        function validateYouTubeJson() {
            const textarea = document.getElementById('editYouTubeLinks');
            try {
                const parsed = JSON.parse(textarea.value);
                if (!Array.isArray(parsed)) {
                    throw new Error('배열 형태가 아닙니다');
                }
                
                for (let i = 0; i < parsed.length; i++) {
                    const item = parsed[i];
                    if (!item.thumbnail_file || !item.youtube_url) {
                        throw new Error(`${i + 1}번째 항목에 필수 필드가 없습니다 (thumbnail_file, youtube_url 필요)`);
                    }
                    
                    // Validate YouTube URL format
                    if (!item.youtube_url.includes('youtu')) {
                        throw new Error(`${i + 1}번째 항목의 YouTube URL이 유효하지 않습니다`);
                    }
                }
                
                Notification.success(`${parsed.length}개 YouTube 링크가 검증되었습니다`);
            } catch (error) {
                Notification.error('검증 실패: ' + error.message);
            }
        }

        // Preview function removed as requested

        // Display current YouTube links with edit/delete options
        function displayCurrentYouTubeLinks(youtubeLinks, asset) {
            const linksDiv = document.getElementById('currentYouTubeLinks');
            if (!youtubeLinks || youtubeLinks.length === 0) {
                linksDiv.innerHTML = '<p class="text-muted">현재 YouTube 링크가 없습니다.</p>';
                return;
            }

            const linksHtml = youtubeLinks.map((link, index) => `
                <div class="card mb-2" data-index="${index}">
                    <div class="card-body p-2">
                        <div class="row align-items-center">
                            <div class="col-md-2">
                                ${link.thumbnail_file ? `
                                    <img src="/asset/${asset.curriculum}/${asset.month}/${link.thumbnail_file}" 
                                         alt="썸네일" 
                                         style="width: 80px; height: 48px; object-fit: cover;" 
                                         class="border rounded"
                                         onerror="this.style.display='none'">
                                ` : '<div class="bg-light border rounded" style="width: 80px; height: 48px; display: flex; align-items: center; justify-content: center;"><i class="fas fa-image text-muted"></i></div>'}
                            </div>
                            <div class="col-md-8">
                                <h6 class="mb-1">${link.title || '제목 없음'}</h6>
                                <small class="text-muted">
                                    <a href="${link.youtube_url}" target="_blank" class="text-decoration-none">
                                        <i class="fab fa-youtube text-danger"></i> ${link.youtube_url}
                                    </a>
                                </small>
                            </div>
                            <div class="col-md-2">
                                <button type="button" class="btn btn-sm btn-outline-danger" onclick="removeYouTubeLink(${index})">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `).join('');

            linksDiv.innerHTML = linksHtml;
        }
        
        // Add new YouTube link
        function addYouTubeLink() {
            const thumbnailFile = document.getElementById('thumbnailFileInput').files[0];
            const youtubeUrl = document.getElementById('youtubeUrl').value.trim();
            const youtubeTitle = document.getElementById('youtubeTitle').value.trim();
            
            if (!thumbnailFile) {
                Notification.warning('썸네일 이미지를 선택해주세요');
                return;
            }
            
            if (!youtubeUrl) {
                Notification.warning('YouTube URL을 입력해주세요');
                return;
            }
            
            if (!youtubeUrl.includes('youtu')) {
                Notification.warning('올바른 YouTube URL을 입력해주세요');
                return;
            }
            
            // Show upload progress
            const progressDiv = document.getElementById('youtubeUploadProgress');
            const statusDiv = document.getElementById('youtubeUploadStatus');
            progressDiv.style.display = 'block';
            statusDiv.textContent = '썸네일 업로드 중...';
            
            // Upload thumbnail first
            const formData = new FormData();
            formData.append('file', thumbnailFile);
            
            fetch('/api/upload', {
                method: 'POST',
                credentials: 'include',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                progressDiv.style.display = 'none';
                
                if (data.success) {
                    // Add to YouTube links
                    const currentLinks = JSON.parse(document.getElementById('editYouTubeLinks').value || '[]');
                    // Convert upload path to thumbnail path relative to curriculum/month folder
                    const filename = data.file_path.split('/').pop();
                    const thumbnailPath = `thumbnail/${filename}`;
                    
                    const newLink = {
                        thumbnail_file: thumbnailPath,
                        youtube_url: youtubeUrl,
                        title: youtubeTitle || '제목 없음'
                    };
                    
                    currentLinks.push(newLink);
                    document.getElementById('editYouTubeLinks').value = JSON.stringify(currentLinks, null, 2);
                    
                    // Update display
                    const assetId = document.getElementById('editYouTubeAssetId').value;
                    const asset = currentAssets.find(a => a.id === assetId);
                    displayCurrentYouTubeLinks(currentLinks, asset);
                    
                    // Reset form
                    document.getElementById('thumbnailFileInput').value = '';
                    document.getElementById('youtubeUrl').value = '';
                    document.getElementById('youtubeTitle').value = '';
                    document.getElementById('thumbnailPreview').innerHTML = '';
                    
                    Notification.success('YouTube 링크가 추가되었습니다');
                } else {
                    Notification.error('썸네일 업로드 실패: ' + data.message);
                }
            })
            .catch(error => {
                progressDiv.style.display = 'none';
                Notification.error('썸네일 업로드 실패: ' + error.message);
            });
        }
        
        // Remove YouTube link
        function removeYouTubeLink(index) {
            const currentLinks = JSON.parse(document.getElementById('editYouTubeLinks').value || '[]');
            currentLinks.splice(index, 1);
            document.getElementById('editYouTubeLinks').value = JSON.stringify(currentLinks, null, 2);
            
            // Update display
            const assetId = document.getElementById('editYouTubeAssetId').value;
            const asset = currentAssets.find(a => a.id === assetId);
            displayCurrentYouTubeLinks(currentLinks, asset);
            
            Notification.info('YouTube 링크가 제거되었습니다');
        }

        function saveYouTubeChanges() {
            const assetId = document.getElementById('editYouTubeAssetId').value;
            const youtubeText = document.getElementById('editYouTubeLinks').value;

            try {
                const youtubeLinks = JSON.parse(youtubeText);
                if (!Array.isArray(youtubeLinks)) {
                    throw new Error('배열 형태가 아닙니다');
                }

                // Validate YouTube links structure
                for (let i = 0; i < youtubeLinks.length; i++) {
                    const item = youtubeLinks[i];
                    if (!item.thumbnail_file || !item.youtube_url) {
                        throw new Error(`${i + 1}번째 항목에 필수 필드가 없습니다`);
                    }
                }

                const updateData = {
                    youtube_links: youtubeLinks
                };

                // Disable save button to prevent double submission
                const saveButton = document.querySelector('#editYouTubeModal .btn-primary');
                saveButton.disabled = true;
                saveButton.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>저장 중...';

                API.put(`/api/assets/${assetId}`, updateData)
                    .then(data => {
                        Notification.success('YouTube 링크가 성공적으로 업데이트되었습니다!');
                        
                        // Hide the modal
                        const modalElement = document.getElementById('editYouTubeModal');
                        const modalInstance = bootstrap.Modal.getInstance(modalElement);
                        modalInstance.hide();
                        
                        // Refresh the assets list
                        loadAssets();
                    })
                    .catch(error => {
                        Notification.error('YouTube 링크 업데이트에 실패했습니다: ' + error.message);
                    })
                    .finally(() => {
                        // Re-enable save button
                        saveButton.disabled = false;
                        saveButton.innerHTML = '저장';
                    });

            } catch (error) {
                Notification.error('잘못된 JSON 형식입니다: ' + error.message);
            }
        }

        // Show folder info panel as sidebar
        function showFolderInfoPanel(item) {
            
            // Extract book ID and title from path
            const pathParts = item.path.split('/').filter(p => p);
            console.log('Debug - showFolderInfoPanel:', {
                itemPath: item.path,
                pathParts: pathParts,
                itemName: item.name
            });
            
            if (pathParts.length < 2) {
                Notification.error('폴더 정보를 가져올 수 없습니다.');
                return;
            }
            
            const bookId = pathParts[0];
            const title = item.name; // Use actual folder name instead of path parsing
            
            console.log('Debug - Extracted values:', { bookId, title, originalPathTitle: pathParts[1] });
            
            // Update sidebar title
            document.getElementById('infoSidebarTitle').textContent = `폴더 정보 - ${title}`;
            
            // Clear all tab contents first
            document.getElementById('videoContent').innerHTML = '<div class="spinner-border" role="status"><span class="visually-hidden">로딩중...</span></div>';
            document.getElementById('imageContent').innerHTML = '<div class="spinner-border" role="status"><span class="visually-hidden">로딩중...</span></div>';
            document.getElementById('subtitleContent').innerHTML = '<div class="text-center"><div class="spinner-border" role="status"><span class="visually-hidden">로딩중...</span></div></div>';
            
            // Reset tabs to default state (video tab active)
            document.querySelectorAll('#folderInfoTabs .nav-link').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-pane').forEach(pane => {
                pane.classList.remove('show', 'active');
            });
            document.getElementById('video-tab').classList.add('active');
            document.getElementById('video-pane').classList.add('show', 'active');
            
            // Show sidebar
            const sidebar = document.getElementById('infoSidebar');
            const overlay = document.getElementById('infoSidebarOverlay');
            
            sidebar.classList.add('open');
            overlay.classList.add('show');
            
            // Store current bookId and title for tab switching
            sidebar.dataset.bookId = bookId;
            sidebar.dataset.title = title;
            
            // Load video content (default active tab)
            loadVideoContent(bookId, title);
            
            // Remove existing event listeners and add new ones
            const videoTab = document.getElementById('video-tab');
            const imageTab = document.getElementById('image-tab');
            const subtitleTab = document.getElementById('subtitle-tab');
            
            // Clone nodes to remove all event listeners
            const newVideoTab = videoTab.cloneNode(true);
            const newImageTab = imageTab.cloneNode(true);
            const newSubtitleTab = subtitleTab.cloneNode(true);
            
            videoTab.parentNode.replaceChild(newVideoTab, videoTab);
            imageTab.parentNode.replaceChild(newImageTab, imageTab);
            subtitleTab.parentNode.replaceChild(newSubtitleTab, subtitleTab);
            
            // Add fresh event listeners with current bookId and title
            newVideoTab.addEventListener('click', () => {
                loadVideoContent(bookId, title);
            });
            newImageTab.addEventListener('click', () => {
                loadImageContent(bookId, title);
            });
            newSubtitleTab.addEventListener('click', () => {
                loadSubtitleContent(bookId, title);
            });
            
            // Add close event listeners
            document.getElementById('closeInfoSidebar').onclick = closeInfoSidebar;
            document.getElementById('infoSidebarOverlay').onclick = closeInfoSidebar;
        }
        
        // Close info sidebar
        function closeInfoSidebar() {
            const sidebar = document.getElementById('infoSidebar');
            const overlay = document.getElementById('infoSidebarOverlay');
            
            sidebar.classList.remove('open');
            overlay.classList.remove('show');
        }

        // Load video content
        function loadVideoContent(bookId, title) {
            const videoContent = document.getElementById('videoContent');
            videoContent.innerHTML = '<div class="spinner-border" role="status"><span class="visually-hidden">로딩중...</span></div>';
            
            // Store current bookId and title for save operation
            videoContent.dataset.bookId = bookId;
            videoContent.dataset.title = title;
            
            // Find video file
            API.get(`/api/folders/${bookId}/${title}`)
                .then(response => {
                    const videoFiles = response.items.filter(item => 
                        item.item_type === 'file' && 
                        item.name.toLowerCase().match(/\.(mp4|mov|avi|mkv|wmv|flv|webm)$/)
                    );
                    
                    if (videoFiles.length > 0) {
                        const primaryVideo = videoFiles.find(vid => vid.name.toLowerCase() === `${title.toLowerCase()}.mp4`) || videoFiles[0];
                        const videoUrl = `https://reengki-assets-r2-worker.reengkigo.workers.dev/player/${bookId}/${title}/${primaryVideo.name}`;
                        const videoPath = `${bookId}/${title}/${primaryVideo.name}`;
                        
                        // Store the path for save operation
                        videoContent.dataset.videoPath = videoPath;
                        videoContent.dataset.fileName = primaryVideo.name;
                        
                        videoContent.innerHTML = `
                            <div class="video-editor">
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <div>
                                        <span class="text-muted">영상 파일: ${videoPath}</span>
                                    </div>
                                    <div>
                                        <button type="button" class="btn btn-sm btn-outline-secondary me-2" onclick="refreshVideoContent()">
                                            <i class="fas fa-sync-alt"></i> 새로고침
                                        </button>
                                        <button type="button" class="btn btn-sm btn-primary" onclick="enableVideoEdit()">
                                            <i class="fas fa-edit"></i> 교체
                                        </button>
                                    </div>
                                </div>
                                
                                <!-- View Mode -->
                                <div id="videoViewMode">
                                    <div class="ratio ratio-16x9" style="max-width: 800px; margin: 0 auto;">
                                        <iframe src="${videoUrl}" frameborder="0" allowfullscreen></iframe>
                                    </div>
                                </div>
                                
                                <!-- Edit Mode (Hidden by default) -->
                                <div id="videoEditMode" style="display: none;">
                                    <div class="mb-3">
                                        <label class="form-label">새 영상 파일 선택</label>
                                        <input type="file" class="form-control" id="videoFileInput" accept="video/*">
                                        <div class="form-text">MP4, MOV, AVI, WebM 등 영상 파일을 선택하세요. (최대 2GB)</div>
                                    </div>
                                    
                                    <div class="mb-3">
                                        <button type="button" class="btn btn-sm btn-secondary" onclick="cancelVideoEdit()">
                                            <i class="fas fa-times"></i> 취소
                                        </button>
                                        <button type="button" class="btn btn-sm btn-success ms-2" onclick="saveVideoChanges()">
                                            <i class="fas fa-save"></i> 저장
                                        </button>
                                    </div>
                                    
                                    <div id="videoValidationResult"></div>
                                    <div id="videoUploadProgress" style="display: none;">
                                        <div class="progress mb-2">
                                            <div class="progress-bar" id="videoProgressBar" role="progressbar" style="width: 0%"></div>
                                        </div>
                                        <div class="text-center" id="videoProgressText">업로드 준비 중...</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        videoContent.innerHTML = `
                            <div class="alert alert-warning">
                                영상 파일이 없습니다.
                                <button type="button" class="btn btn-sm btn-primary ms-3" onclick="enableVideoEdit(true)">
                                    <i class="fas fa-plus"></i> 새 영상 업로드
                                </button>
                            </div>
                        `;
                    }
                })
                .catch(error => {
                    videoContent.innerHTML = `
                        <div class="alert alert-warning">
                            영상을 불러올 수 없습니다.
                            <button type="button" class="btn btn-sm btn-primary ms-3" onclick="enableVideoEdit(true)">
                                <i class="fas fa-plus"></i> 새 영상 업로드
                            </button>
                        </div>
                    `;
                });
        }

        // Load image content  
        function loadImageContent(bookId, title) {
            const imageContent = document.getElementById('imageContent');
            imageContent.innerHTML = '<div class="spinner-border" role="status"><span class="visually-hidden">로딩중...</span></div>';
            
            console.log('Debug - loadImageContent called with:', { bookId, title });
            
            // Store current bookId and title for save operation
            imageContent.dataset.bookId = bookId;
            imageContent.dataset.title = title;
            
            console.log('Debug - Dataset set in loadImageContent:', {
                bookId: imageContent.dataset.bookId,
                title: imageContent.dataset.title
            });
            
            // Find image files
            API.get(`/api/folders/${bookId}/${title}`)
                .then(response => {
                    const imageFiles = response.items.filter(item => 
                        item.item_type === 'file' && 
                        item.name.toLowerCase().match(/\.(jpg|jpeg|png|gif|bmp|webp)$/)
                    );
                    
                    if (imageFiles.length > 0) {
                        const primaryImage = imageFiles.find(img => img.name.toLowerCase() === `${title.toLowerCase()}.jpg` || img.name.toLowerCase() === `${title.toLowerCase()}.png`) || imageFiles[0];
                        // Add timestamp to prevent browser caching
                        const imageUrl = `/api/image/${bookId}/${title}?t=${Date.now()}`;
                        const imagePath = `${bookId}/${title}/${primaryImage.name}`;
                        
                        // Store the path for save operation
                        imageContent.dataset.imagePath = imagePath;
                        imageContent.dataset.fileName = primaryImage.name;
                        
                        imageContent.innerHTML = `
                            <div class="image-editor">
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <div>
                                        <span class="text-muted">이미지 파일: ${imagePath}</span>
                                    </div>
                                    <div>
                                        <button type="button" class="btn btn-sm btn-outline-secondary me-2" onclick="refreshImageContent()">
                                            <i class="fas fa-sync-alt"></i> 새로고침
                                        </button>
                                        <button type="button" class="btn btn-sm btn-primary" onclick="enableImageEdit()">
                                            <i class="fas fa-edit"></i> 교체
                                        </button>
                                    </div>
                                </div>
                                
                                <!-- View Mode -->
                                <div id="imageViewMode">
                                    <div class="text-center">
                                        <img src="${imageUrl}" 
                                             class="img-fluid border rounded" 
                                             style="max-width: 100%; max-height: 400px; object-fit: contain;" 
                                             alt="이미지"
                                             onload="this.style.opacity='1'"
                                             style="opacity: 0; transition: opacity 0.3s ease;">
                                    </div>
                                </div>
                                
                                <!-- Edit Mode (Hidden by default) -->
                                <div id="imageEditMode" style="display: none;">
                                    <div class="mb-3">
                                        <label class="form-label">새 이미지 파일 선택</label>
                                        <input type="file" class="form-control" id="imageFileInput" accept="image/*">
                                        <div class="form-text">JPG, PNG, GIF, WebP 등 이미지 파일을 선택하세요.</div>
                                    </div>
                                    
                                    <div class="mb-3">
                                        <button type="button" class="btn btn-sm btn-secondary" onclick="cancelImageEdit()">
                                            <i class="fas fa-times"></i> 취소
                                        </button>
                                        <button type="button" class="btn btn-sm btn-success ms-2" onclick="saveImageChanges()">
                                            <i class="fas fa-save"></i> 저장
                                        </button>
                                    </div>
                                    
                                    <div id="imageValidationResult"></div>
                                </div>
                            </div>
                        `;
                    } else {
                        imageContent.innerHTML = `
                            <div class="alert alert-warning">
                                이미지 파일이 없습니다.
                                <button type="button" class="btn btn-sm btn-primary ms-3" onclick="enableImageEdit(true)">
                                    <i class="fas fa-plus"></i> 새 이미지 업로드
                                </button>
                            </div>
                        `;
                    }
                })
                .catch(error => {
                    imageContent.innerHTML = `
                        <div class="alert alert-warning">
                            이미지를 불러올 수 없습니다.
                            <button type="button" class="btn btn-sm btn-primary ms-3" onclick="enableImageEdit(true)">
                                <i class="fas fa-plus"></i> 새 이미지 업로드
                            </button>
                        </div>
                    `;
                });
        }

        // Load subtitle content
        function loadSubtitleContent(bookId, title) {
            const subtitleContent = document.getElementById('subtitleContent');
            subtitleContent.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"><span class="visually-hidden">로딩중...</span></div></div>';
            
            // Store current bookId and title for save operation
            subtitleContent.dataset.bookId = bookId;
            subtitleContent.dataset.title = title;
            
            // Use internal API endpoint
            API.get(`/api/subtitle/${bookId}/${title}`)
                .then(response => {
                    
                    if (!response.success) {
                        throw new Error(response.error || '자막 데이터 로드 실패');
                    }
                    
                    const subtitleData = response.data;
                    const subtitlePath = response.path || `${bookId}/${title}/subtitle.json`;
                    const subtitleFilename = response.filename || 'subtitle.json';
                    
                    // Store the path and filename for save operation
                    subtitleContent.dataset.subtitlePath = subtitlePath;
                    subtitleContent.dataset.subtitleFilename = subtitleFilename;
                    
                    if (!subtitleData || subtitleData.length === 0) {
                        subtitleContent.innerHTML = `
                            <div class="alert alert-warning">
                                자막 데이터가 없습니다.
                                <button type="button" class="btn btn-sm btn-primary ms-3" onclick="enableSubtitleEdit(true)">
                                    <i class="fas fa-plus"></i> 새 자막 생성
                                </button>
                            </div>
                        `;
                        return;
                    }
                    
                    // Display subtitle data with edit mode similar to editSubtitlesModal
                    const subtitleHtml = `
                        <div class="subtitle-editor">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <div>
                                    <span class="text-muted">자막 파일: ${subtitlePath}</span>
                                </div>
                                <div>
                                    <button type="button" class="btn btn-sm btn-outline-secondary me-2" onclick="refreshSubtitleContent()">
                                        <i class="fas fa-sync-alt"></i> 새로고침
                                    </button>
                                    <button type="button" class="btn btn-sm btn-primary" id="editSubtitleBtn" onclick="enableSubtitleEdit()">
                                        <i class="fas fa-edit"></i> 수정
                                    </button>
                                </div>
                            </div>
                            
                            <!-- View Mode -->
                            <div id="subtitleViewMode">
                                <div class="table-responsive" style="max-height: 500px; overflow-y: auto;">
                                    <table class="table table-sm table-striped table-hover">
                                        <thead class="table-light sticky-top">
                                            <tr>
                                                <th class="text-center" style="width: 12%; color: black; font-size: 13px;">페이지</th>
                                                <th class="text-center" style="width: 12%; color: black; font-size: 13px;">문장</th>
                                                <th style="width: 76%; color: black; font-size: 13px; padding-left: 15px;">텍스트</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${subtitleData.map((item, index) => `
                                                <tr>
                                                    <td class="text-center">
                                                        <span class="badge bg-primary">${item.page_num || 'N/A'}</span>
                                                    </td>
                                                    <td class="text-center">
                                                        <span class="badge bg-secondary">${item.sentence_num || 'N/A'}</span>
                                                    </td>
                                                    <td class="text-start" style="font-size: 14px; line-height: 1.5;">${item.text || ''}</td>
                                                </tr>
                                            `).join('')}
                                        </tbody>
                                    </table>
                                    <div class="text-muted small mt-2">
                                        총 ${subtitleData.length}개의 자막 항목
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Edit Mode (Hidden by default) -->
                            <div id="subtitleEditMode" style="display: none;">
                                <div class="mb-3">
                                    <div class="d-flex justify-content-between align-items-center mb-2">
                                        <label class="form-label mb-0">자막 목록</label>
                                        <button type="button" class="btn btn-sm btn-outline-primary" onclick="addSubtitleItem()">
                                            <i class="fas fa-plus"></i> 자막 추가
                                        </button>
                                    </div>
                                    <div id="subtitleItemsList" class="border rounded p-3" style="max-height: 500px; overflow-y: auto;">
                                        <!-- Subtitle items will be populated here -->
                                    </div>
                                </div>
                                
                                <div class="mb-3">
                                    <button type="button" class="btn btn-sm btn-secondary" onclick="cancelSubtitleEdit()">
                                        <i class="fas fa-times"></i> 취소
                                    </button>
                                    <button type="button" class="btn btn-sm btn-success ms-2" onclick="saveSubtitleChanges()">
                                        <i class="fas fa-save"></i> 저장
                                    </button>
                                </div>
                                
                                <div id="subtitleValidationResult"></div>
                            </div>
                        </div>
                    `;
                    
                    subtitleContent.innerHTML = subtitleHtml;
                })
                .catch(error => {
                    subtitleContent.innerHTML = `
                        <div class="alert alert-warning">
                            자막 데이터가 없습니다.
                            <button type="button" class="btn btn-sm btn-primary ms-3" onclick="enableSubtitleEdit(true)">
                                <i class="fas fa-plus"></i> 새 자막 생성
                            </button>
                        </div>
                    `;
                });
        }
        
        // Refresh functions for each content type
        function refreshSubtitleContent() {
            const subtitleContent = document.getElementById('subtitleContent');
            const bookId = subtitleContent.dataset.bookId;
            const title = subtitleContent.dataset.title;
            
            if (bookId && title) {
                loadSubtitleContent(bookId, title);
            }
        }
        
        function refreshImageContent() {
            const imageContent = document.getElementById('imageContent');
            const bookId = imageContent.dataset.bookId;
            const title = imageContent.dataset.title;
            
            if (bookId && title) {
                // Clear any existing image cache by adding a small delay and clearing content first
                imageContent.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"><span class="visually-hidden">로딩중...</span></div><div class="mt-2">새로고침 중...</div></div>';
                
                // Use a small timeout to ensure the loading state is shown
                setTimeout(() => {
                    loadImageContent(bookId, title);
                }, 100);
            }
        }
        
        function refreshVideoContent() {
            const videoContent = document.getElementById('videoContent');
            const bookId = videoContent.dataset.bookId;
            const title = videoContent.dataset.title;
            
            if (bookId && title) {
                loadVideoContent(bookId, title);
            }
        }
        
        // Enable subtitle edit mode
        function enableSubtitleEdit(isNew = false) {
            const subtitleContent = document.getElementById('subtitleContent');
            
            if (isNew) {
                // Create new subtitle editor
                const bookId = subtitleContent.dataset.bookId;
                const title = subtitleContent.dataset.title;
                const subtitleFilename = 'subtitle.json'; // Default for new files
                const subtitlePath = `${bookId}/${title}/${subtitleFilename}`;
                
                subtitleContent.dataset.subtitlePath = subtitlePath;
                subtitleContent.dataset.subtitleFilename = subtitleFilename;
                
                const newSubtitleHtml = `
                    <div class="subtitle-editor">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <div>
                                <span class="text-muted">새 자막 파일: ${subtitlePath}</span>
                            </div>
                        </div>
                        
                        <div id="subtitleEditMode">
                            <div class="mb-3">
                                <div class="d-flex justify-content-between align-items-center mb-2">
                                    <label class="form-label mb-0">자막 목록</label>
                                    <div>
                                        <button type="button" class="btn btn-sm btn-outline-secondary me-2" onclick="sortSubtitleItems()" title="정렬">
                                            <i class="fas fa-sort"></i> 정렬
                                        </button>
                                        <button type="button" class="btn btn-sm btn-outline-primary" onclick="addSubtitleItem()">
                                            <i class="fas fa-plus"></i> 자막 추가
                                        </button>
                                    </div>
                                </div>
                                <div id="subtitleItemsList" class="border rounded p-3" style="max-height: 500px; overflow-y: auto;">
                                    <!-- Subtitle items will be added here -->
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <button type="button" class="btn btn-sm btn-secondary" onclick="cancelSubtitleEdit()">
                                    <i class="fas fa-times"></i> 취소
                                </button>
                                <button type="button" class="btn btn-sm btn-success ms-2" onclick="saveSubtitleChanges()">
                                    <i class="fas fa-save"></i> 저장
                                </button>
                            </div>
                            
                            <div id="subtitleValidationResult"></div>
                        </div>
                    </div>
                `;
                
                subtitleContent.innerHTML = newSubtitleHtml;
                
                // Add initial subtitle item
                addSubtitleItem();
            } else {
                // Switch to edit mode
                const viewMode = document.getElementById('subtitleViewMode');
                const editMode = document.getElementById('subtitleEditMode');
                const editBtn = document.getElementById('editSubtitleBtn');
                
                if (viewMode) viewMode.style.display = 'none';
                if (editMode) editMode.style.display = 'block';
                if (editBtn) editBtn.style.display = 'none';
                
                // Load existing subtitle data into form
                loadExistingSubtitleData();
            }
        }
        
        // Cancel subtitle edit
        function cancelSubtitleEdit() {
            const subtitleContent = document.getElementById('subtitleContent');
            const bookId = subtitleContent.dataset.bookId;
            const title = subtitleContent.dataset.title;
            
            // Reload subtitle content
            loadSubtitleContent(bookId, title);
        }
        
        // Add new subtitle item
        function addSubtitleItem(pageNum = 1, sentenceNum = 1, text = '') {
            const subtitlesList = document.getElementById('subtitleItemsList');
            if (!subtitlesList) return;
            
            const itemId = `subtitle-item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            const itemHtml = `
                <div class="subtitle-item border rounded p-3 mb-2" id="${itemId}">
                    <div class="row g-3 align-items-start">
                        <div class="col-lg-2 col-md-3">
                            <label class="form-label small mb-1">페이지</label>
                            <input type="number" class="form-control form-control-sm page-num" value="${pageNum}" min="1" step="1">
                        </div>
                        <div class="col-lg-2 col-md-3">
                            <label class="form-label small mb-1">문장</label>
                            <input type="number" class="form-control form-control-sm sentence-num" value="${sentenceNum}" min="1" step="1">
                        </div>
                        <div class="col-lg-7 col-md-5">
                            <label class="form-label small mb-1">텍스트</label>
                            <textarea class="form-control form-control-sm subtitle-text" rows="3" placeholder="자막 텍스트를 입력하세요" style="resize: vertical; line-height: 1.5;">${text}</textarea>
                        </div>
                        <div class="col-lg-1 col-md-1 d-flex align-items-end">
                            <button type="button" class="btn btn-sm btn-outline-danger" onclick="removeSubtitleItem('${itemId}')" title="삭제">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            subtitlesList.insertAdjacentHTML('beforeend', itemHtml);
        }
        
        // Sort subtitle items by splitting text with line breaks
        function sortSubtitleItems() {
            const subtitlesList = document.getElementById('subtitleItemsList');
            if (!subtitlesList) return;
            
            // Get all subtitle items
            const items = subtitlesList.querySelectorAll('.subtitle-item');
            if (items.length === 0) {
                Notification.warning('정렬할 자막이 없습니다.');
                return;
            }
            
            // Collect all text from existing items
            let allTexts = [];
            let currentPageNum = 1;
            
            items.forEach(item => {
                const textArea = item.querySelector('.subtitle-text');
                const pageInput = item.querySelector('.page-num');
                if (textArea && textArea.value.trim()) {
                    if (pageInput && pageInput.value) {
                        currentPageNum = parseInt(pageInput.value) || 1;
                    }
                    // Split text by line breaks
                    const lines = textArea.value.split('\n').filter(line => line.trim());
                    lines.forEach(line => {
                        allTexts.push({
                            page: currentPageNum,
                            text: line.trim()
                        });
                    });
                }
            });
            
            if (allTexts.length === 0) {
                Notification.warning('정렬할 텍스트가 없습니다.');
                return;
            }
            
            // Clear existing items
            subtitlesList.innerHTML = '';
            
            // Create new items for each line
            let sentenceNum = 1;
            allTexts.forEach((item, index) => {
                addSubtitleItem(item.page, sentenceNum++, item.text);
            });
            
            Notification.success(`텍스트가 ${allTexts.length}개의 문장으로 분리되었습니다.`);
        }
        
        // Remove subtitle item
        function removeSubtitleItem(itemId) {
            const item = document.getElementById(itemId);
            if (item) {
                item.remove();
            }
        }
        
        // Load existing subtitle data into form
        function loadExistingSubtitleData() {
            const subtitleContent = document.getElementById('subtitleContent');
            const bookId = subtitleContent.dataset.bookId;
            const title = subtitleContent.dataset.title;
            
            // Clear existing items
            const subtitlesList = document.getElementById('subtitleItemsList');
            if (subtitlesList) {
                subtitlesList.innerHTML = '';
            }
            
            // Try to get subtitle data from API
            API.get(`/api/subtitle/${bookId}/${title}`)
                .then(response => {
                    if (response.success && response.data && Array.isArray(response.data)) {
                        const subtitleData = response.data;
                        
                        if (subtitleData.length > 0) {
                            // Load existing subtitle items
                            subtitleData.forEach(item => {
                                addSubtitleItem(
                                    item.page_num || 1, 
                                    item.sentence_num || 1, 
                                    item.text || ''
                                );
                            });
                        } else {
                            // No subtitle data, add one empty item
                            addSubtitleItem();
                        }
                    } else {
                        // No subtitle file found, add one empty item
                        addSubtitleItem();
                    }
                })
                .catch(error => {
                    console.error('Error loading subtitle data:', error);
                    // Add one empty item if loading fails
                    addSubtitleItem();
                });
        }
        
        // Show validation message
        function showSubtitleValidation(message, type) {
            const resultDiv = document.getElementById('subtitleValidationResult');
            if (!resultDiv) return;
            
            resultDiv.innerHTML = `<div class="alert alert-${type} mt-2">${message}</div>`;
            
            if (type === 'success') {
                setTimeout(() => {
                    resultDiv.innerHTML = '';
                }, 3000);
            }
        }
        
        // Save subtitle changes
        async function saveSubtitleChanges() {
            const subtitleContent = document.getElementById('subtitleContent');
            if (!subtitleContent) return;
            
            const bookId = subtitleContent.dataset.bookId;
            const title = subtitleContent.dataset.title;
            const subtitleFilename = subtitleContent.dataset.subtitleFilename || 'subtitle.json';
            const subtitlePath = `${bookId}/${title}/${subtitleFilename}`;
            
            console.log('Debug - Saving subtitle:', {
                bookId,
                title,
                subtitlePath,
                subtitleFilename
            });
            
            try {
                // Collect data from form
                const subtitleData = collectSubtitleData();
                
                if (!subtitleData || subtitleData.length === 0) {
                    throw new Error('자막 데이터가 없습니다');
                }
                
                // Validate data
                for (let i = 0; i < subtitleData.length; i++) {
                    const item = subtitleData[i];
                    if (!item.page_num || !item.sentence_num || !item.text.trim()) {
                        throw new Error(`자막 항목 ${i + 1}: 페이지 번호, 문장 번호, 텍스트를 모두 입력해주세요`);
                    }
                }
                
                // Show loading state
                showSubtitleValidation('저장 중...', 'info');
                
                // Create a Blob from the JSON data
                const jsonBlob = new Blob([JSON.stringify(subtitleData, null, 2)], { type: 'application/json' });
                const file = new File([jsonBlob], subtitleFilename, { type: 'application/json' });
                
                // Upload the file using the new endpoint
                const formData = new FormData();
                formData.append('file', file);
                formData.append('full_path', subtitlePath);
                
                const response = await fetch('/api/upload-file', {
                    method: 'POST',
                    credentials: 'include',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error('파일 업로드 실패');
                }
                
                const result = await response.json();
                
                if (result.success) {
                    showSubtitleValidation('자막이 성공적으로 저장되었습니다!', 'success');
                    
                    // Wait a moment then reload the subtitle content
                    setTimeout(() => {
                        loadSubtitleContent(bookId, title);
                    }, 1500);
                } else {
                    throw new Error(result.error || '저장 실패');
                }
                
            } catch (e) {
                showSubtitleValidation('저장 실패: ' + e.message, 'danger');
            }
        }
        
        // Collect subtitle data from form
        function collectSubtitleData() {
            const subtitlesList = document.getElementById('subtitleItemsList');
            if (!subtitlesList) return [];
            
            const items = subtitlesList.querySelectorAll('.subtitle-item');
            const subtitleData = [];
            
            items.forEach(item => {
                const pageNum = parseInt(item.querySelector('.page-num').value) || 1;
                const sentenceNum = parseInt(item.querySelector('.sentence-num').value) || 1;
                const text = item.querySelector('.subtitle-text').value.trim();
                
                if (text) { // Only include items with text
                    subtitleData.push({
                        page_num: pageNum,
                        sentence_num: sentenceNum,
                        text: text
                    });
                }
            });
            
            // Sort by page_num, then by sentence_num
            subtitleData.sort((a, b) => {
                if (a.page_num !== b.page_num) {
                    return a.page_num - b.page_num;
                }
                return a.sentence_num - b.sentence_num;
            });
            
            return subtitleData;
        }
        
        // Image edit functions
        function enableImageEdit(isNew = false) {
            const imageContent = document.getElementById('imageContent');
            
            if (isNew) {
                // Create new image editor - we'll determine filename when file is selected
                const bookId = imageContent.dataset.bookId;
                const title = imageContent.dataset.title;
                
                // Clear any existing fileName dataset for new uploads
                delete imageContent.dataset.fileName;
                console.log('Debug - Cleared fileName dataset for new image upload');
                
                imageContent.innerHTML = `
                    <div class="image-editor">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <div>
                                <span class="text-muted">새 이미지 업로드: ${bookId}/${title}/</span>
                            </div>
                        </div>
                        
                        <div id="imageEditMode">
                            <div class="mb-3">
                                <label class="form-label">이미지 파일 선택</label>
                                <input type="file" class="form-control" id="imageFileInput" accept="image/*">
                                <div class="form-text">JPG, PNG, GIF, WebP 등 이미지 파일을 선택하세요. 파일명은 자동으로 "${title}.확장자"로 저장됩니다.</div>
                            </div>
                            
                            <div class="mb-3">
                                <button type="button" class="btn btn-sm btn-secondary" onclick="cancelImageEdit()">
                                    <i class="fas fa-times"></i> 취소
                                </button>
                                <button type="button" class="btn btn-sm btn-success ms-2" onclick="saveImageChanges()">
                                    <i class="fas fa-save"></i> 저장
                                </button>
                            </div>
                            
                            <div id="imageValidationResult"></div>
                        </div>
                    </div>
                `;
            } else {
                // Switch to edit mode
                const viewMode = document.getElementById('imageViewMode');
                const editMode = document.getElementById('imageEditMode');
                const editBtn = document.querySelector('.image-editor .btn-primary');
                
                if (viewMode) viewMode.style.display = 'none';
                if (editMode) editMode.style.display = 'block';
                if (editBtn) editBtn.style.display = 'none';
            }
        }
        
        function cancelImageEdit() {
            const imageContent = document.getElementById('imageContent');
            const bookId = imageContent.dataset.bookId;
            const title = imageContent.dataset.title;
            
            // Reload image content
            loadImageContent(bookId, title);
        }
        
        function showImageValidation(message, type) {
            const resultDiv = document.getElementById('imageValidationResult');
            if (!resultDiv) return;
            
            resultDiv.innerHTML = `<div class="alert alert-${type} mt-2">${message}</div>`;
            
            if (type === 'success') {
                setTimeout(() => {
                    resultDiv.innerHTML = '';
                }, 3000);
            }
        }
        
        async function saveImageChanges() {
            const fileInput = document.getElementById('imageFileInput');
            const imageContent = document.getElementById('imageContent');
            
            if (!fileInput || !imageContent || !fileInput.files.length) {
                showImageValidation('파일을 선택해주세요.', 'danger');
                return;
            }
            
            const file = fileInput.files[0];
            const bookId = imageContent.dataset.bookId;
            const title = imageContent.dataset.title;
            
            console.log('Debug - saveImageChanges datasets:', {
                bookId: imageContent.dataset.bookId,
                title: imageContent.dataset.title,
                fileName: imageContent.dataset.fileName,
                allDatasets: imageContent.dataset
            });
            
            // Determine filename based on whether this is a new upload or existing file edit
            let targetFileName;
            if (imageContent.dataset.fileName) {
                // Editing existing file - keep original filename
                targetFileName = imageContent.dataset.fileName;
                console.log('Debug - Using existing fileName:', targetFileName);
            } else {
                // New upload - use title as filename with original file extension
                const fileExtension = file.name.split('.').pop().toLowerCase();
                targetFileName = `${title}.${fileExtension}`;
                console.log('Debug - Creating new fileName:', {
                    originalFileName: file.name,
                    fileExtension,
                    title,
                    targetFileName
                });
            }
            const imagePath = `${bookId}/${title}/${targetFileName}`;
            
            console.log('Debug - Final path:', imagePath);
            
            console.log('Debug - Saving image:', {
                bookId,
                title,
                imagePath,
                fileName: targetFileName,
                fileSize: file.size,
                isNewUpload: !imageContent.dataset.fileName
            });
            
            try {
                // Validate file type
                if (!file.type.startsWith('image/')) {
                    throw new Error('이미지 파일만 업로드할 수 있습니다.');
                }
                
                // Show loading state
                showImageValidation('업로드 중...', 'info');
                
                // Upload the file using the new endpoint with correct filename
                const formData = new FormData();
                const renamedFile = new File([file], targetFileName, { type: file.type });
                formData.append('file', renamedFile);
                formData.append('full_path', imagePath);
                
                const response = await fetch('/api/upload-file', {
                    method: 'POST',
                    credentials: 'include',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error('파일 업로드 실패');
                }
                
                const result = await response.json();
                
                if (result.success) {
                    showImageValidation('이미지가 성공적으로 저장되었습니다! 파일 동기화 중...', 'success');
                    
                    // Start auto-sync process
                    startAutoSyncAfterUpload(bookId, title, targetFileName);
                } else {
                    throw new Error(result.error || '저장 실패');
                }
                
            } catch (e) {
                showImageValidation('저장 실패: ' + e.message, 'danger');
            }
        }
        
        // Auto-sync after image upload
        async function startAutoSyncAfterUpload(bookId, title, expectedFileName) {
            let attempts = 0;
            const maxAttempts = 5;
            const checkInterval = 2000; // 2 seconds
            
            console.log('Debug - Starting auto-sync for file:', expectedFileName);
            
            const checkFileExists = async () => {
                try {
                    attempts++;
                    console.log(`Debug - Sync attempt ${attempts}/${maxAttempts}`);
                    
                    showImageValidation(`파일 동기화 확인 중... (${attempts}/${maxAttempts})`, 'info');
                    
                    // Check if file exists in folder
                    const response = await API.get(`/api/folders/${bookId}/${title}`);
                    const imageFiles = response.items.filter(item => 
                        item.item_type === 'file' && 
                        item.name.toLowerCase().match(/\.(jpg|jpeg|png|gif|bmp|webp)$/) &&
                        item.name === expectedFileName
                    );
                    
                    if (imageFiles.length > 0) {
                        // File found! Success
                        console.log('Debug - File sync successful:', expectedFileName);
                        showImageValidation('파일 동기화 완료! 이미지를 새로고침합니다.', 'success');
                        
                        setTimeout(() => {
                            loadImageContent(bookId, title);
                            refreshAssets(); // Also refresh the main view
                        }, 1000);
                        
                        return true; // Success
                    } else if (attempts >= maxAttempts) {
                        // Max attempts reached
                        console.log('Debug - File sync failed after max attempts');
                        showImageValidation(
                            `파일 동기화에 시간이 걸리고 있습니다. <button type="button" class="btn btn-sm btn-primary ms-2" onclick="manualRefreshAfterSync('${bookId}', '${title}')">새로고침 버튼 누르기</button>`, 
                            'warning'
                        );
                        return false; // Failed
                    } else {
                        // Try again after interval
                        setTimeout(checkFileExists, checkInterval);
                        return null; // Continue
                    }
                    
                } catch (error) {
                    console.error('Debug - Sync check error:', error);
                    if (attempts >= maxAttempts) {
                        showImageValidation(
                            `동기화 확인 중 오류가 발생했습니다. <button type="button" class="btn btn-sm btn-primary ms-2" onclick="manualRefreshAfterSync('${bookId}', '${title}')">새로고침 버튼 누르기</button>`, 
                            'warning'
                        );
                        return false;
                    } else {
                        setTimeout(checkFileExists, checkInterval);
                        return null;
                    }
                }
            };
            
            // Start checking
            checkFileExists();
        }
        
        // Manual refresh function for when auto-sync fails
        function manualRefreshAfterSync(bookId, title) {
            showImageValidation('수동 새로고침 중...', 'info');
            
            // Clear cache and refresh
            clearAllCache()
                .then(() => {
                    loadAssets(); // Refresh main view
                    loadImageContent(bookId, title); // Refresh image content
                    showImageValidation('새로고침 완료!', 'success');
                })
                .catch(() => {
                    loadAssets();
                    loadImageContent(bookId, title);
                    showImageValidation('새로고침 완료!', 'success');
                });
        }
        
        // Video edit functions
        function enableVideoEdit(isNew = false) {
            const videoContent = document.getElementById('videoContent');
            
            if (isNew) {
                // Create new video editor - we'll determine filename when file is selected
                const bookId = videoContent.dataset.bookId;
                const title = videoContent.dataset.title;
                
                videoContent.innerHTML = `
                    <div class="video-editor">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <div>
                                <span class="text-muted">새 영상 파일: ${videoPath}</span>
                            </div>
                        </div>
                        
                        <div id="videoEditMode">
                            <div class="mb-3">
                                <label class="form-label">영상 파일 선택</label>
                                <input type="file" class="form-control" id="videoFileInput" accept="video/*">
                                <div class="form-text">MP4, MOV, AVI, WebM 등 영상 파일을 선택하세요. (최대 2GB)</div>
                            </div>
                            
                            <div class="mb-3">
                                <button type="button" class="btn btn-sm btn-secondary" onclick="cancelVideoEdit()">
                                    <i class="fas fa-times"></i> 취소
                                </button>
                                <button type="button" class="btn btn-sm btn-success ms-2" onclick="saveVideoChanges()">
                                    <i class="fas fa-save"></i> 저장
                                </button>
                            </div>
                            
                            <div id="videoValidationResult"></div>
                            <div id="videoUploadProgress" style="display: none;">
                                <div class="progress mb-2">
                                    <div class="progress-bar" id="videoProgressBar" role="progressbar" style="width: 0%"></div>
                                </div>
                                <div class="text-center" id="videoProgressText">업로드 준비 중...</div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // Switch to edit mode
                const viewMode = document.getElementById('videoViewMode');
                const editMode = document.getElementById('videoEditMode');
                const editBtn = document.querySelector('.video-editor .btn-primary');
                
                if (viewMode) viewMode.style.display = 'none';
                if (editMode) editMode.style.display = 'block';
                if (editBtn) editBtn.style.display = 'none';
            }
        }
        
        function cancelVideoEdit() {
            const videoContent = document.getElementById('videoContent');
            const bookId = videoContent.dataset.bookId;
            const title = videoContent.dataset.title;
            
            // Reload video content
            loadVideoContent(bookId, title);
        }
        
        function showVideoValidation(message, type) {
            const resultDiv = document.getElementById('videoValidationResult');
            if (!resultDiv) return;
            
            resultDiv.innerHTML = `<div class="alert alert-${type} mt-2">${message}</div>`;
            
            if (type === 'success') {
                setTimeout(() => {
                    resultDiv.innerHTML = '';
                }, 3000);
            }
        }
        
        function updateVideoProgress(percent, message) {
            const progressDiv = document.getElementById('videoUploadProgress');
            const progressBar = document.getElementById('videoProgressBar');
            const progressText = document.getElementById('videoProgressText');
            
            if (progressDiv && progressBar && progressText) {
                progressDiv.style.display = 'block';
                progressBar.style.width = percent + '%';
                progressBar.setAttribute('aria-valuenow', percent);
                progressText.textContent = message || `${percent}% 완료`;
            }
        }
        
        async function saveVideoChanges() {
            const fileInput = document.getElementById('videoFileInput');
            const videoContent = document.getElementById('videoContent');
            
            if (!fileInput || !videoContent || !fileInput.files.length) {
                showVideoValidation('파일을 선택해주세요.', 'danger');
                return;
            }
            
            const file = fileInput.files[0];
            const bookId = videoContent.dataset.bookId;
            const title = videoContent.dataset.title;
            
            // Use existing filename if available, otherwise use uploaded filename
            const originalFileName = videoContent.dataset.fileName || file.name;
            const videoPath = `${bookId}/${title}/${originalFileName}`;
            
            console.log('Debug - Saving video:', {
                bookId,
                title,
                videoPath,
                fileName: originalFileName,
                fileSize: file.size
            });
            
            try {
                // Validate file type
                if (!file.type.startsWith('video/')) {
                    throw new Error('비디오 파일만 업로드할 수 있습니다.');
                }
                
                // Check file size (2GB limit)
                const maxSize = 2 * 1024 * 1024 * 1024; // 2GB
                if (file.size > maxSize) {
                    throw new Error('파일 크기가 2GB를 초과합니다.');
                }
                
                // Show loading state
                showVideoValidation('업로드 중...', 'info');
                updateVideoProgress(0, '업로드 준비 중...');
                
                // Create XHR for progress tracking
                const xhr = new XMLHttpRequest();
                const formData = new FormData();
                const renamedFile = new File([file], originalFileName, { type: file.type });
                formData.append('file', renamedFile);
                formData.append('full_path', videoPath);
                
                // Set up progress tracking
                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable) {
                        const percent = Math.round((e.loaded / e.total) * 100);
                        updateVideoProgress(percent, `업로드 중... ${percent}%`);
                    }
                });
                
                // Set up completion handlers
                xhr.onload = function() {
                    if (xhr.status === 200) {
                        try {
                            const result = JSON.parse(xhr.responseText);
                            if (result.success) {
                                updateVideoProgress(100, '업로드 완료!');
                                showVideoValidation('영상이 성공적으로 저장되었습니다!', 'success');
                                
                                // Wait a moment then reload the video content
                                setTimeout(() => {
                                    loadVideoContent(bookId, title);
                                }, 1500);
                            } else {
                                throw new Error(result.error || '저장 실패');
                            }
                        } catch (parseError) {
                            throw new Error('서버 응답 처리 실패');
                        }
                    } else {
                        throw new Error('업로드 실패 (HTTP ' + xhr.status + ')');
                    }
                };
                
                xhr.onerror = function() {
                    showVideoValidation('네트워크 오류가 발생했습니다.', 'danger');
                    document.getElementById('videoUploadProgress').style.display = 'none';
                };
                
                // Start upload
                xhr.open('POST', '/api/upload-file');
                xhr.withCredentials = true;
                xhr.send(formData);
                
            } catch (e) {
                showVideoValidation('저장 실패: ' + e.message, 'danger');
                document.getElementById('videoUploadProgress').style.display = 'none';
            }
        }
    </script>
    <!-- Info Sidebar -->
    <div class="info-sidebar-overlay" id="infoSidebarOverlay"></div>
    <div class="info-sidebar" id="infoSidebar">
        <div class="info-sidebar-header d-flex justify-content-between align-items-center">
            <h5 class="mb-0" id="infoSidebarTitle">폴더 정보</h5>
            <button type="button" class="btn-close" id="closeInfoSidebar"></button>
        </div>
        <div class="info-sidebar-content">
            <!-- Tab Navigation -->
            <ul class="nav nav-tabs mb-3" id="folderInfoTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="video-tab" data-bs-toggle="tab" data-bs-target="#video-pane" type="button" role="tab">
                        <i class="fas fa-video me-2"></i>영상
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="image-tab" data-bs-toggle="tab" data-bs-target="#image-pane" type="button" role="tab">
                        <i class="fas fa-image me-2"></i>이미지
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="subtitle-tab" data-bs-toggle="tab" data-bs-target="#subtitle-pane" type="button" role="tab">
                        <i class="fas fa-closed-captioning me-2"></i>자막
                    </button>
                </li>
            </ul>
            
            <!-- Tab Content -->
            <div class="tab-content" id="folderInfoTabsContent">
                <!-- Video Tab -->
                <div class="tab-pane fade show active" id="video-pane" role="tabpanel">
                    <div id="videoContent" class="text-center">
                        <div class="spinner-border" role="status">
                            <span class="visually-hidden">로딩중...</span>
                        </div>
                    </div>
                </div>
                
                <!-- Image Tab -->
                <div class="tab-pane fade" id="image-pane" role="tabpanel">
                    <div id="imageContent" class="text-center">
                        <div class="spinner-border" role="status">
                            <span class="visually-hidden">로딩중...</span>
                        </div>
                    </div>
                </div>
                
                <!-- Subtitle Tab -->
                <div class="tab-pane fade" id="subtitle-pane" role="tabpanel">
                    <div id="subtitleContent">
                        <div class="text-center">
                            <div class="spinner-border" role="status">
                                <span class="visually-hidden">로딩중...</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

</body>
</html>